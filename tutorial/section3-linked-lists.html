<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Section 3 - Linked Lists &amp; Recursion</title>

    <!-- Site styles -->
    <link rel="stylesheet" href="css/site.css">

    <!-- Highlight.js theme (initial, can be changed via selector) -->
    <link id="hljs-theme" rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

    <!-- highlight.js core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- highlight.js languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

    <!-- Site scripts (tab logic, highlight init, etc.) -->
    <script src="js/site.js"></script>

    <!-- Favicon -->
    <link rel="icon" href="img/icon.svg" type="image/svg+xml" sizes="any">
</head>

<body>
    <main>
        <div class="top-nav">
            <a href="index.html">← Back to Index</a>
        </div>
        <div class="kicker">Section 3</div>
        <h1>Linked Lists &amp; Recursion</h1>
        <p class="tagline">
            Linked lists let you insert and remove elements efficiently without shifting neighbors.
            Recursion is a way to express solutions that naturally follow the structure of a list or tree.
        </p>

        <h2>
            3.1 What Is a Linked List?
            <button type="button" class="deep-dive-trigger" data-deep-id="deep-dive-s3-what-is-ll">
                Dig deeper
            </button>
        </h2>
        <p>
            A <strong>linked list</strong> is a sequence of nodes where each node holds a value and a reference
            (or pointer) to the next node. The list is usually accessed by a pointer or reference to the
            first node, called the <strong>head</strong>.
        </p>
        <ul class="bullet-tight">
            <li><strong>Singly linked list</strong>: each node points only to the next node.</li>
            <li><strong>Doubly linked list</strong>: each node points to both the next and previous node.</li>
            <li>No random access: we reach the k-th element by walking from the head in <strong>O(k)</strong> time.</li>
        </ul>
        <p>
            Linked lists trade away fast indexed access (arrays) in exchange for cheaper insertions and
            deletions in the middle, if you already have a pointer to the right place.
        </p>

        <h2>
            3.2 Recap: Time Complexity for Linked Lists
            <button type="button" class="deep-dive-trigger" data-deep-id="deep-dive-s3-complexity">
                Dig deeper
            </button>
        </h2>
        <ul>
            <li><strong>Traversal</strong> over all nodes: <strong>O(n)</strong>.</li>
            <li><strong>Insert or delete</strong> after a given node (and you already have that node):
                <strong>O(1)</strong>.
            </li>
            <li><strong>Find by index</strong> (k-th element): <strong>O(k)</strong>, worst case <strong>O(n)</strong>.
            </li>
        </ul>

        <h2>
            3.3 Recursion and the Call Stack
            <button type="button" class="deep-dive-trigger" data-deep-id="deep-dive-s3-recursion">
                Dig deeper
            </button>
        </h2>
        <p>
            A <strong>recursive function</strong> calls itself on a smaller subproblem. For lists, the natural
            smaller piece is often "the list starting at the next node". Each call is pushed onto the
            <strong>call stack</strong>, and when it returns, it is popped off.
        </p>
        <p>
            To avoid infinite recursion you need:
        </p>
        <ul>
            <li>A <strong>base case</strong> that returns without recursing further.</li>
            <li>A <strong>step</strong> that moves toward the base case (for example, advancing the node pointer).</li>
        </ul>

        <h2>3.4 Code Examples in Multiple Languages</h2>
        <p>
            As in earlier sections, each example appears in six languages:
            <strong>C, C++, Java, JavaScript, C#,</strong> and <strong>Python</strong>. Use the language tabs
            to switch between them.
        </p>

        <div class="theme-picker">
            <label for="theme-select">Syntax theme:</label>
            <select id="theme-select">
                <option value="atom-one-dark" selected>Dark</option>
                <option value="far">Blue</option>
                <option value="atom-one-light">Light</option>
            </select>
        </div>

        <hr>

        <!-- ======================= Example 1 ======================= -->
        <h3>
            3.5 Example 1 - Singly Linked List Node &amp; Insert at Head
            <button type="button" class="deep-dive-trigger inline" data-deep-id="deep-dive-s3-ex1">
                Dig deeper
            </button>
        </h3>
        <p>
            We will define a singly linked list node and implement a helper that inserts a new value
            at the head of the list. This is often the simplest way to build up a list.
        </p>

        <div class="code-example" data-example="s3-ex1">
            <div class="code-example-header">
                <div class="code-example-title">
                    <span class="label">Example 1</span>
                    <span class="meta">Define a node and insert at head</span>
                </div>
                <button type="button" class="copy-button" aria-label="Copy code">
                    Copy
                </button>
            </div>

            <div class="tab-bar">
                <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
            </div>

            <div class="code-panel" data-lang-panel="c">
                <pre><code class="language-c">// C
#include &lt;stdlib.h&gt;

typedef struct Node {
    int value;
    struct Node* next;
} Node;

Node* push_front(Node* head, int value) {
    Node* new_node = (Node*)malloc(sizeof(Node));
    if (!new_node) return head;  // allocation failed, return old head
    new_node-&gt;value = value;
    new_node-&gt;next = head;
    return new_node;
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="cpp">
                <pre><code class="language-cpp">// C++
struct Node {
    int value;
    Node* next;
    Node(int v, Node* n = nullptr) : value(v), next(n) {}
};

Node* pushFront(Node* head, int value) {
    Node* newNode = new Node(value, head);
    return newNode;
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="java">
                <pre><code class="language-java">// Java
class ListNode {
    int value;
    ListNode next;

    ListNode(int value, ListNode next) {
        this.value = value;
        this.next = next;
    }
}

ListNode pushFront(ListNode head, int value) {
    return new ListNode(value, head);
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="js">
                <pre><code class="language-javascript">// JavaScript
class ListNode {
    constructor(value, next = null) {
        this.value = value;
        this.next = next;
    }
}

function pushFront(head, value) {
    return new ListNode(value, head);
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="cs">
                <pre><code class="language-csharp">// C#
class ListNode {
    public int Value;
    public ListNode? Next;

    public ListNode(int value, ListNode? next = null) {
        Value = value;
        Next = next;
    }
}

ListNode? PushFront(ListNode? head, int value) {
    return new ListNode(value, head);
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="py">
                <pre><code class="language-python"># Python
class ListNode:
    def __init__(self, value: int, next: "ListNode | None" = None):
        self.value = value
        self.next = next

def push_front(head: "ListNode | None", value: int) -&gt; "ListNode":
    return ListNode(value, head)</code></pre>
            </div>

            <div class="complexity-note">
                Time: <strong>O(1)</strong> - a fixed number of pointer updates. &nbsp;|&nbsp;
                Extra space: <strong>O(1)</strong> per insertion (one new node).
            </div>
        </div>

        <!-- ======================= Example 2 ======================= -->
        <h3>
            3.6 Example 2 - Traverse and Print a Linked List
            <button type="button" class="deep-dive-trigger inline" data-deep-id="deep-dive-s3-ex2">
                Dig deeper
            </button>
        </h3>
        <p>
            Now we traverse the list from head to tail, printing each node's value. This is the
            linked list analog of iterating through an array.
        </p>

        <div class="code-example" data-example="s3-ex2">
            <div class="code-example-header">
                <div class="code-example-title">
                    <span class="label">Example 2</span>
                    <span class="meta">Iterative traversal</span>
                </div>
                <button type="button" class="copy-button" aria-label="Copy code">
                    Copy
                </button>
            </div>

            <div class="tab-bar">
                <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
            </div>

            <div class="code-panel" data-lang-panel="c">
                <pre><code class="language-c">// C
#include &lt;stdio.h&gt;

void print_list(Node* head) {
    Node* current = head;
    while (current != NULL) {
        printf("%d\n", current-&gt;value);
        current = current-&gt;next;
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="cpp">
                <pre><code class="language-cpp">// C++
#include &lt;iostream&gt;

void printList(Node* head) {
    Node* current = head;
    while (current != nullptr) {
        std::cout &lt;&lt; current-&gt;value &lt;&lt; std::endl;
        current = current-&gt;next;
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="java">
                <pre><code class="language-java">// Java
void printList(ListNode head) {
    ListNode current = head;
    while (current != null) {
        System.out.println(current.value);
        current = current.next;
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="js">
                <pre><code class="language-javascript">// JavaScript
function printList(head) {
    let current = head;
    while (current !== null) {
        console.log(current.value);
        current = current.next;
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="cs">
                <pre><code class="language-csharp">// C#
void PrintList(ListNode? head) {
    var current = head;
    while (current != null) {
        Console.WriteLine(current.Value);
        current = current.Next;
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="py">
                <pre><code class="language-python"># Python
def print_list(head: "ListNode | None") -&gt; None:
    current = head
    while current is not None:
        print(current.value)
        current = current.next</code></pre>
            </div>

            <div class="complexity-note">
                Time: <strong>O(n)</strong> - we visit every node once. &nbsp;|&nbsp;
                Extra space: <strong>O(1)</strong>.
            </div>
        </div>

        <!-- ======================= Example 3 ======================= -->
        <h3>
            3.7 Example 3 - Reverse a Linked List (Iterative)
            <button type="button" class="deep-dive-trigger inline" data-deep-id="deep-dive-s3-ex3">
                Dig deeper
            </button>
        </h3>
        <p>
            A classic interview problem: reverse a singly linked list in place. We maintain
            three pointers: <code>prev</code>, <code>current</code>, and <code>next</code>.
        </p>

        <div class="code-example" data-example="s3-ex3">
            <div class="code-example-header">
                <div class="code-example-title">
                    <span class="label">Example 3</span>
                    <span class="meta">Reverse a list iteratively</span>
                </div>
                <button type="button" class="copy-button" aria-label="Copy code">
                    Copy
                </button>
            </div>

            <div class="tab-bar">
                <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
            </div>

            <div class="code-panel" data-lang-panel="c">
                <pre><code class="language-c">// C
Node* reverse_list(Node* head) {
    Node* prev = NULL;
    Node* current = head;
    while (current != NULL) {
        Node* next_node = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next_node;
    }
    return prev;
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="cpp">
                <pre><code class="language-cpp">// C++
Node* reverseList(Node* head) {
    Node* prev = nullptr;
    Node* current = head;
    while (current != nullptr) {
        Node* nextNode = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = nextNode;
    }
    return prev;
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="java">
                <pre><code class="language-java">// Java
ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode current = head;
    while (current != null) {
        ListNode nextNode = current.next;
        current.next = prev;
        prev = current;
        current = nextNode;
    }
    return prev;
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="js">
                <pre><code class="language-javascript">// JavaScript
function reverseList(head) {
    let prev = null;
    let current = head;
    while (current !== null) {
        const nextNode = current.next;
        current.next = prev;
        prev = current;
        current = nextNode;
    }
    return prev;
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="cs">
                <pre><code class="language-csharp">// C#
ListNode? ReverseList(ListNode? head) {
    ListNode? prev = null;
    var current = head;
    while (current != null) {
        var nextNode = current.Next;
        current.Next = prev;
        prev = current;
        current = nextNode;
    }
    return prev;
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="py">
                <pre><code class="language-python"># Python
def reverse_list(head: "ListNode | None") -&gt; "ListNode | None":
    prev = None
    current = head
    while current is not None:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    return prev</code></pre>
            </div>

            <div class="complexity-note">
                Time: <strong>O(n)</strong> - we visit each node once. &nbsp;|&nbsp;
                Extra space: <strong>O(1)</strong> - in-place reversal.
            </div>
        </div>

        <!-- ======================= Example 4 ======================= -->
        <h3>
            3.8 Example 4 - Recursively Print a Linked List
            <button type="button" class="deep-dive-trigger inline" data-deep-id="deep-dive-s3-ex4">
                Dig deeper
            </button>
        </h3>
        <p>
            This example shows a simple recursive pattern: print the current node, then recursively
            print the rest of the list. The structure of the code mirrors the structure of the list.
        </p>

        <div class="code-example" data-example="s3-ex4">
            <div class="code-example-header">
                <div class="code-example-title">
                    <span class="label">Example 4</span>
                    <span class="meta">Recursive traversal</span>
                </div>
                <button type="button" class="copy-button" aria-label="Copy code">
                    Copy
                </button>
            </div>

            <div class="tab-bar">
                <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
            </div>

            <div class="code-panel" data-lang-panel="c">
                <pre><code class="language-c">// C
#include &lt;stdio.h&gt;

void print_list_recursive(Node* head) {
    if (head == NULL) {
        return;  // base case: empty list
    }
    printf("%d\n", head-&gt;value);
    print_list_recursive(head-&gt;next);
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="cpp">
                <pre><code class="language-cpp">// C++
#include &lt;iostream&gt;

void printListRecursive(Node* head) {
    if (head == nullptr) return;
    std::cout &lt;&lt; head-&gt;value &lt;&lt; std::endl;
    printListRecursive(head-&gt;next);
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="java">
                <pre><code class="language-java">// Java
void printListRecursive(ListNode head) {
    if (head == null) {
        return;
    }
    System.out.println(head.value);
    printListRecursive(head.next);
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="js">
                <pre><code class="language-javascript">// JavaScript
function printListRecursive(head) {
    if (head === null) {
        return;
    }
    console.log(head.value);
    printListRecursive(head.next);
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="cs">
                <pre><code class="language-csharp">// C#
void PrintListRecursive(ListNode? head) {
    if (head == null) {
        return;
    }
    Console.WriteLine(head.Value);
    PrintListRecursive(head.Next);
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="py">
                <pre><code class="language-python"># Python
def print_list_recursive(head: "ListNode | None") -&gt; None:
    if head is None:
        return
    print(head.value)
    print_list_recursive(head.next)</code></pre>
            </div>

            <div class="complexity-note">
                Time: <strong>O(n)</strong> - one call per node. &nbsp;|&nbsp;
                Extra space: <strong>O(n)</strong> for the call stack (one frame per node).
            </div>
        </div>

        <h2>3.9 Quick Practice</h2>
        <p>For each of these, think about both time and space complexity (including recursion stack space):</p>
        <ol>
            <li>
                Write a function that counts the number of nodes in a linked list iteratively.<br>
                <details class="practice-details">
                    <summary>Show answer...</summary>
                    <div>
                        <strong>1.</strong> We walk the list once, incrementing a counter.<br>
                        Time: <strong>O(n)</strong>.<br>
                        Extra space: <strong>O(1)</strong>.
                    </div>
                </details>
            </li>
            <li>
                Write a recursive function that counts the number of nodes in a linked list.<br>
                <details class="practice-details">
                    <summary>Show answer...</summary>
                    <div>
                        <strong>2.</strong> One recursive call per node.<br>
                        Time: <strong>O(n)</strong>.<br>
                        Extra space: <strong>O(n)</strong> for the call stack.
                    </div>
                </details>
            </li>
            <li>
                Modify the recursive print function so that it prints the list in reverse order.<br>
                <details class="practice-details">
                    <summary>Show answer...</summary>
                    <div>
                        <strong>3.</strong> Recurse first, then print on the way back up.<br>
                        Time: <strong>O(n)</strong> (still one call per node).<br>
                        Extra space: <strong>O(n)</strong> for the call stack.
                    </div>
                </details>
            </li>
            <li>
                Consider reversing a linked list recursively instead of iteratively. What happens to
                time and space complexity?<br>
                <details class="practice-details">
                    <summary>Show answer...</summary>
                    <div>
                        <strong>4.</strong> Each node is still visited a constant number of times.<br>
                        Time: <strong>O(n)</strong>.<br>
                        Extra space: <strong>O(n)</strong> for recursion, instead of <strong>O(1)</strong> iteratively.
                    </div>
                </details>
            </li>
            <li>
                Suppose you insert a new node at the tail of a singly linked list when you only have
                a pointer to the head (no tail pointer). What is the time complexity of a single
                insertion?<br>
                <details class="practice-details">
                    <summary>Show answer...</summary>
                    <div>
                        <strong>5.</strong> You must traverse from head to the last node to find the tail.<br>
                        Time: <strong>O(n)</strong> per insertion.<br>
                        Extra space: <strong>O(1)</strong>.
                    </div>
                </details>
            </li>
        </ol>

        <div class="top-nav">
            <a href="problems-section3-linked-lists.html">
                Problem Set for Section 3 Linked Lists →
            </a>
        </div>
        <div class="next-section">
            <a href="section2-arrays-strings.html">
                ← Back to Section 2
            </a>
            &nbsp;&nbsp;
            <a href="section4-stacks-queues.html">
                Next: Section 4 - Stacks &amp; Queues →
            </a>
        </div>

        <!-- ======================= Deep dive templates ======================= -->

        <div class="deep-dive-template" id="deep-dive-s3-what-is-ll" data-title="How linked lists really work in memory"
            hidden>
            <p>
                A linked list is fundamentally different from an array in how it lives in memory:
            </p>
            <ul>
                <li>
                    <strong>Array:</strong> elements are stored in one contiguous block. The address of
                    <code>arr[i]</code> can be computed as <code>base + i * element_size</code>, which is why
                    indexed access is typically O(1).
                </li>
                <li>
                    <strong>Linked list:</strong> each node can live anywhere in memory. The <code>next</code>
                    pointer stores the address/reference of the following node.
                </li>
            </ul>
            <p>
                This has two big consequences:
            </p>
            <ul>
                <li>
                    <strong>Pros:</strong> insert/delete after a node is just rewiring a couple of pointers (no
                    shifting).
                </li>
                <li>
                    <strong>Cons:</strong> no random access — to reach the k-th element you must follow pointers from
                    the head.
                </li>
            </ul>
            <p>
                Interview tip: whenever a problem emphasizes “lots of insertions/removals in the middle” or “splice
                nodes”
                and does <em>not</em> require random indexing, a linked list is often worth considering.
            </p>
        </div>

        <div class="deep-dive-template" id="deep-dive-s3-complexity" data-title="Complexity trade-offs for linked lists"
            hidden>
            <p>
                Linked list complexity usually depends on whether you already have a pointer to the right spot.
            </p>
            <ul>
                <li>
                    <strong>Traversal:</strong> visit all nodes once → O(n).
                </li>
                <li>
                    <strong>Insert/delete after a known node:</strong> constant pointer rewiring → O(1).
                </li>
                <li>
                    <strong>Find by index (k-th):</strong> follow <code>next</code> pointers k times → O(k), worst-case
                    O(n).
                </li>
            </ul>
            <p>
                Common “design upgrades” that show up as follow-ups:
            </p>
            <ul>
                <li>
                    <strong>Tail pointer:</strong> makes append O(1) instead of O(n).
                </li>
                <li>
                    <strong>Dummy/sentinel head:</strong> simplifies edge cases when inserting/deleting at the front.
                </li>
                <li>
                    <strong>Doubly linked list:</strong> can delete a node in O(1) if you have the node, because you can
                    rewire both sides.
                </li>
            </ul>
        </div>

        <div class="deep-dive-template" id="deep-dive-s3-recursion"
            data-title="Recursion, call stacks, and when to use them" hidden>
            <p>
                Recursion works by placing one “frame” per call on the call stack. Each frame stores parameters, local
                variables,
                and where to resume when the call returns.
            </p>
            <p>
                For a linked list of length <code>n</code>, a typical recursive traversal:
            </p>
            <ul>
                <li>Makes one call per node → O(n) time.</li>
                <li>Uses one stack frame per node → O(n) extra space <em>from the call stack</em>.</li>
            </ul>
            <p>
                <strong>Two rules prevent infinite recursion:</strong>
            </p>
            <ul>
                <li><strong>Base case:</strong> stop when the node pointer is null.</li>
                <li><strong>Progress:</strong> move toward null (usually by calling on <code>node.next</code>).</li>
            </ul>
            <p>
                Practical note: recursion is often the cleanest explanation in an interview, but in production code
                extremely long lists can risk stack overflow in languages without guaranteed tail-call optimization.
            </p>
        </div>

        <div class="deep-dive-template" id="deep-dive-s3-ex1"
            data-title="Insert-at-head: the pointer wiring (and edge cases)" hidden>
            <p>
                Inserting at the head is the simplest linked list operation because it always touches the same pointers.
            </p>
            <p>
                <strong>Invariant:</strong> you must not lose the old head — store it in <code>newNode.next</code>
                before changing what “head” points to.
            </p>
            <ol>
                <li>Create/allocate a new node.</li>
                <li>Set <code>newNode.value</code>.</li>
                <li>Set <code>newNode.next = head</code>.</li>
                <li>Return <code>newNode</code> as the new head.</li>
            </ol>
            <p>
                Edge cases are naturally handled:
            </p>
            <ul>
                <li><strong>Empty list:</strong> if <code>head</code> is null, then <code>newNode.next</code> becomes
                    null — still valid.</li>
                <li><strong>Memory allocation (C/C++):</strong> allocation can fail; returning the old head is a safe
                    default.</li>
            </ul>
        </div>

        <div class="deep-dive-template" id="deep-dive-s3-ex2" data-title="Traversal patterns and common pitfalls"
            hidden>
            <p>
                Traversal is the linked-list version of a simple array loop, but you must be careful about null
                pointers.
            </p>
            <p>
                <strong>Invariant:</strong> before reading <code>current.value</code> or <code>current.next</code>,
                ensure
                <code>current</code> is not null.
            </p>
            <ul>
                <li>Initialize <code>current = head</code>.</li>
                <li>While <code>current != null</code>, process the node and advance:
                    <code>current = current.next</code>.</li>
            </ul>
            <p>
                Variations you’ll see later:
            </p>
            <ul>
                <li><strong>Fast/slow pointers:</strong> for finding midpoints or detecting cycles.</li>
                <li><strong>Prev/current pointers:</strong> for deletions while scanning.</li>
                <li><strong>Dummy head:</strong> helps when you might remove the real head.</li>
            </ul>
        </div>

        <div class="deep-dive-template" id="deep-dive-s3-ex3" data-title="Reverse a list in-place: the core invariant"
            hidden>
            <p>
                Reversing a singly linked list is mostly about not losing the remainder of the list while you flip
                pointers.
            </p>
            <p>
                <strong>Main invariant:</strong>
            </p>
            <ul>
                <li><code>prev</code> points to the head of the already-reversed prefix.</li>
                <li><code>current</code> points to the head of the not-yet-reversed suffix.</li>
            </ul>
            <p>
                Each loop iteration does the same 4 moves:
            </p>
            <ol>
                <li>Save the remainder: <code>next = current.next</code>.</li>
                <li>Flip the link: <code>current.next = prev</code>.</li>
                <li>Advance <code>prev</code> to <code>current</code>.</li>
                <li>Advance <code>current</code> to <code>next</code>.</li>
            </ol>
            <p>
                When <code>current</code> becomes null, <code>prev</code> is the new head.
            </p>
            <p>
                Interview follow-up you can answer immediately: recursive reversal is still O(n) time, but uses O(n)
                stack space instead of O(1).
            </p>
        </div>

        <div class="deep-dive-template" id="deep-dive-s3-ex4"
            data-title="Recursive printing and printing in reverse order" hidden>
            <p>
                The recursive print mirrors the shape of the list: “print this node, then print the rest.”
            </p>
            <p>
                <strong>Base case:</strong> if <code>head</code> is null, return.
            </p>
            <p>
                <strong>Forward order:</strong> print first, recurse second:
            </p>
            <ul>
                <li>Print <code>head.value</code></li>
                <li>Call on <code>head.next</code></li>
            </ul>
            <p>
                <strong>Reverse order:</strong> recurse first, print on the way back up:
            </p>
            <ul>
                <li>Call on <code>head.next</code></li>
                <li>Print <code>head.value</code></li>
            </ul>
            <p>
                That’s the key recursion “trick”: the call stack naturally reverses the order of operations.
                Time stays O(n), but stack space is O(n).
            </p>
        </div>

        <!-- ======================= Deep dive modal shell ======================= -->

        <div class="deep-dive-backdrop" id="deep-dive-backdrop" aria-hidden="true">
            <div class="deep-dive-modal" role="dialog" aria-modal="true" aria-labelledby="deep-dive-title">
                <button type="button" class="deep-dive-close" aria-label="Close">&times;</button>
                <h2 id="deep-dive-title">&npsp;</h2>
                <div class="deep-dive-body"></div>
            </div>
        </div>

    </main>
</body>

</html>
