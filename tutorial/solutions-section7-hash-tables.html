<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Solutions - Section 7 Hash Tables</title>

    <!-- Site styles -->
    <link rel="stylesheet" href="css/site.css">

    <!-- Highlight.js theme (initial, can be changed via selector) -->
    <link id="hljs-theme" rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

    <!-- highlight.js core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- highlight.js languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

    <!-- Site scripts -->
    <script src="js/site.js"></script>

    <!-- Favicon -->
    <link rel="icon" href="img/icon.svg" type="image/svg+xml" sizes="any">
</head>

<body>
    <main>
        <div class="top-nav">
            <a href="section10-practice.html">← Back to Practice Hub</a>
            &nbsp;&nbsp;
            <a href="problems-section7-hash-tables.html">← Back to Section 7 Problems</a>
            &nbsp;&nbsp;
            <a href="section7-hash-tables.html">View Section 7 Lesson →</a>
        </div>

        <div class="kicker">Section 7 - Solutions</div>
        <h1>Hash Tables - Solutions</h1>
        <p class="tagline">
            Detailed solutions for the Section 7 hash table problems: first unique character, grouping anagrams,
            longest consecutive sequence, subarray sums, and two-sum variants. Each core solution is shown in
            C, C++, Java, JavaScript, C#, and Python.
        </p>

        <div class="theme-picker">
            <label for="theme-select">Syntax theme:</label>
            <select id="theme-select">
                <option value="atom-one-dark">Dark</option>
                <option value="far">Blue</option>
                <option value="atom-one-light">Light</option>
            </select>
        </div>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 1 - First Non-Repeating Character                 -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 1 - First Non-Repeating Character in a String</h2>
            <p>
                Strategy: make one pass to count frequencies of each character, then a second pass to find the
                first index whose frequency is exactly 1.
            </p>

            <div class="code-example" data-example="s7p1">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 1</span>
                        <span class="meta">First unique character index</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s7p1">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C
#include &lt;stdio.h&gt;

int firstUniqChar(const char *s) {
    int freq[256] = {0};
    const unsigned char *p;

    // First pass: count frequencies
    for (p = (const unsigned char *)s; *p != '\0'; ++p) {
        freq[*p]++;
    }

    // Second pass: find first index with freq == 1
    int idx = 0;
    for (p = (const unsigned char *)s; *p != '\0'; ++p, ++idx) {
        if (freq[*p] == 1) {
            return idx;
        }
    }
    return -1;
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

int firstUniqChar(const string &amp;s) {
    vector&lt;int&gt; freq(256, 0);
    for (unsigned char ch : s) {
        freq[ch]++;
    }
    for (int i = 0; i &lt; (int)s.size(); i++) {
        if (freq[(unsigned char)s[i]] == 1) {
            return i;
        }
    }
    return -1;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
int firstUniqChar(String s) {
    int[] freq = new int[256];
    for (int i = 0; i &lt; s.length(); i++) {
        freq[s.charAt(i)]++;
    }
    for (int i = 0; i &lt; s.length(); i++) {
        if (freq[s.charAt(i)] == 1) {
            return i;
        }
    }
    return -1;
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
function firstUniqChar(s) {
    const freq = {};
    for (const ch of s) {
        freq[ch] = (freq[ch] || 0) + 1;
    }
    for (let i = 0; i &lt; s.length; i++) {
        if (freq[s[i]] === 1) {
            return i;
        }
    }
    return -1;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
using System.Collections.Generic;

int FirstUniqChar(string s) {
    var freq = new Dictionary&lt;char, int&gt;();
    foreach (char ch in s) {
        freq[ch] = freq.TryGetValue(ch, out int c) ? c + 1 : 1;
    }
    for (int i = 0; i &lt; s.Length; i++) {
        if (freq[s[i]] == 1) {
            return i;
        }
    }
    return -1;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
from typing import Dict

def first_uniq_char(s: str) -&gt; int:
    freq: Dict[str, int] = {}
    for ch in s:
        freq[ch] = freq.get(ch, 0) + 1
    for i, ch in enumerate(s):
        if freq[ch] == 1:
            return i
    return -1</code></pre>
                </div>

                <div class="complexity-note">
                    Time: two passes over length n → <strong>O(n)</strong>.  
                    Space: at most one entry per distinct character → <strong>O(min(n, alphabet))</strong>.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 2 - Group Anagrams                                -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 2 - Group Anagrams</h2>
            <p>
                Key idea: two strings are anagrams if they share the same <strong>signature</strong>.
                The simplest signature is the sorted string. Use that as a hash key to group words.
            </p>

            <div class="code-example" data-example="s7p2">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 2</span>
                        <span class="meta">Group anagrams by sorted-string key</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s7p2">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C (conceptual; assumes helper map from char* key to list of strings) -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C (conceptual sketch)
//
// In C, you would typically implement this by:
// 1. Sorting a copy of each string as the key.
// 2. Using a hash table mapping key string -&gt; dynamic array of original strings.
// The details depend on your hash table implementation, so we show high-level steps here.

#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

// Pseudocode-level only:
void groupAnagrams(char **strs, int strsSize /*, HashMap *map */) {
    for (int i = 0; i &lt; strsSize; i++) {
        char *s = strs[i];
        int len = (int)strlen(s);

        char *key = (char *)malloc(len + 1);
        strcpy(key, s);
        qsort(key, len, sizeof(char), (int (*)(const void*, const void*))strcmp); // or custom char cmp

        // hash_map_add(map, key, s);
        // where map groups values by identical key strings

        // free key once map stores its own copy
    }
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
using namespace std;

vector&lt;vector&lt;string&gt; &gt; groupAnagrams(const vector&lt;string&gt; &amp;strs) {
    unordered_map&lt;string, vector&lt;string&gt; &gt; mp;
    for (const string &amp;s : strs) {
        string key = s;
        sort(key.begin(), key.end());
        mp[key].push_back(s);
    }
    vector&lt;vector&lt;string&gt; &gt; result;
    result.reserve(mp.size());
    for (auto &amp;kv : mp) {
        result.push_back(move(kv.second));
    }
    return result;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
import java.util.*;

List&lt;List&lt;String&gt; &gt; groupAnagrams(String[] strs) {
    Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();
    for (String s : strs) {
        char[] chars = s.toCharArray();
        Arrays.sort(chars);
        String key = new String(chars);
        map.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(s);
    }
    return new ArrayList&lt;&gt;(map.values());
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
function groupAnagrams(strs) {
    const map = new Map();
    for (const s of strs) {
        const key = s.split("").sort().join("");
        if (!map.has(key)) {
            map.set(key, []);
        }
        map.get(key).push(s);
    }
    return Array.from(map.values());
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
using System;
using System.Collections.Generic;
using System.Linq;

IList&lt;IList&lt;string&gt; &gt; GroupAnagrams(string[] strs) {
    var map = new Dictionary&lt;string, List&lt;string&gt;&gt;();
    foreach (var s in strs) {
        var chars = s.ToCharArray();
        Array.Sort(chars);
        var key = new string(chars);
        if (!map.TryGetValue(key, out var list)) {
            list = new List&lt;string&gt;();
            map[key] = list;
        }
        list.Add(s);
    }
    return map.Values.Cast&lt;IList&lt;string&gt; &gt;().ToList();
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
from collections import defaultdict
from typing import List

def group_anagrams(strs: List[str]) -&gt; List[List[str]]:
    groups: defaultdict[str, List[str]] = defaultdict(list)
    for s in strs:
        key = "".join(sorted(s))
        groups[key].append(s)
    return list(groups.values())</code></pre>
                </div>

                <div class="complexity-note">
                    Let n be the number of strings and m the maximum length.  
                    Sorting each string costs O(m log m), so time is <strong>O(n m log m)</strong>.  
                    Extra space: <strong>O(n m)</strong> to store keys and groups.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 3 - Longest Consecutive Sequence                  -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 3 - Longest Consecutive Sequence</h2>
            <p>
                Load all numbers into a set. For each number x, only attempt to grow a sequence starting at x
                if x - 1 is not in the set. Then walk forward x, x+1, x+2, ... to count the chain length.
            </p>

            <div class="code-example" data-example="s7p3">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 3</span>
                        <span class="meta">O(n) expected using a hash set</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s7p3">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C (conceptual; requires hash-set implementation) -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C (conceptual sketch)
//
// Assume you have a HashSet of ints with operations:
//   set_add(&amp;set, x);
//   set_contains(&amp;set, x);
//   set_iterate(&amp;set, callback).
// The high-level algorithm mirrors the other languages.

int longestConsecutive(int *nums, int numsSize /*, HashSet *set */) {
    // 1. Insert all nums[i] into set.
    // 2. For each x in set:
    //      if (!set_contains(set, x - 1)):
    //          cur = x; length = 1;
    //          while (set_contains(set, cur + 1)):
    //              cur++; length++;
    //          update best.
    // 3. Return best.
    return 0; // Placeholder: actual code depends on your set implementation.
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
#include &lt;unordered_set&gt;
#include &lt;vector&gt;
using namespace std;

int longestConsecutive(const vector&lt;int&gt; &amp;nums) {
    unordered_set&lt;int&gt; set(nums.begin(), nums.end());
    int best = 0;

    for (int x : set) {
        if (!set.count(x - 1)) { // start of a sequence
            int cur = x;
            int length = 1;
            while (set.count(cur + 1)) {
                cur++;
                length++;
            }
            if (length &gt; best) best = length;
        }
    }
    return best;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
import java.util.*;

int longestConsecutive(int[] nums) {
    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
    for (int x : nums) set.add(x);

    int best = 0;
    for (int x : set) {
        if (!set.contains(x - 1)) { // start of sequence
            int cur = x;
            int length = 1;
            while (set.contains(cur + 1)) {
                cur++;
                length++;
            }
            best = Math.max(best, length);
        }
    }
    return best;
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
function longestConsecutive(nums) {
    const set = new Set(nums);
    let best = 0;

    for (const x of set) {
        if (!set.has(x - 1)) {
            let cur = x;
            let length = 1;
            while (set.has(cur + 1)) {
                cur++;
                length++;
            }
            if (length &gt; best) best = length;
        }
    }
    return best;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
using System.Collections.Generic;

int LongestConsecutive(int[] nums) {
    var set = new HashSet&lt;int&gt;(nums);
    int best = 0;

    foreach (var x in set) {
        if (!set.Contains(x - 1)) {
            int cur = x;
            int length = 1;
            while (set.Contains(cur + 1)) {
                cur++;
                length++;
            }
            if (length &gt; best) best = length;
        }
    }
    return best;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
from typing import List

def longest_consecutive(nums: List[int]) -&gt; int:
    s = set(nums)
    best = 0
    for x in s:
        if x - 1 not in s:
            cur = x
            length = 1
            while cur + 1 in s:
                cur += 1
                length += 1
            best = max(best, length)
    return best</code></pre>
                </div>

                <div class="complexity-note">
                    Each element starts a sequence at most once and each value is advanced through once overall.  
                    Time: <strong>O(n)</strong> expected.  
                    Space: <strong>O(n)</strong> for the set.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 4 - Subarray Sum Equals K                         -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 4 - Subarray Sum Equals K</h2>
            <p>
                Use a running prefix sum and a hash map from prefix value to count of occurrences so far.
                For each new prefix, any earlier prefix equal to <code>prefix - k</code> forms a subarray
                summing to <code>k</code>.
            </p>

            <div class="code-example" data-example="s7p4">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 4</span>
                        <span class="meta">Prefix sums + frequency map</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s7p4">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C (conceptual; needs hash map of int->int) -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C (conceptual sketch)
//
// Requires a hash map from int prefix sum -&gt; int count.
// Pseudocode:
//
// int subarraySum(int *nums, int numsSize, int k) {
//     HashMap freq;
//     hash_init(&amp;freq);
//     hash_put(&amp;freq, 0, 1);
//     int prefix = 0;
//     int count = 0;
//     for (int i = 0; i &lt; numsSize; i++) {
//         prefix += nums[i];
//         int need = prefix - k;
//         count += hash_get_or_default(&amp;freq, need, 0);
//         hash_put(&amp;freq, prefix, hash_get_or_default(&amp;freq, prefix, 0) + 1);
//     }
//     return count;
// }</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
using namespace std;

int subarraySum(const vector&lt;int&gt; &amp;nums, int k) {
    unordered_map&lt;int, int&gt; freq;
    freq[0] = 1;
    int prefix = 0;
    int count = 0;
    for (int x : nums) {
        prefix += x;
        int need = prefix - k;
        if (freq.count(need)) {
            count += freq[need];
        }
        freq[prefix]++;
    }
    return count;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
import java.util.*;

int subarraySum(int[] nums, int k) {
    Map&lt;Integer, Integer&gt; freq = new HashMap&lt;&gt;();
    freq.put(0, 1);
    int prefix = 0;
    int count = 0;

    for (int x : nums) {
        prefix += x;
        int need = prefix - k;
        count += freq.getOrDefault(need, 0);
        freq.put(prefix, freq.getOrDefault(prefix, 0) + 1);
    }
    return count;
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
function subarraySum(nums, k) {
    const freq = new Map();
    freq.set(0, 1);
    let prefix = 0;
    let count = 0;

    for (const x of nums) {
        prefix += x;
        const need = prefix - k;
        if (freq.has(need)) {
            count += freq.get(need);
        }
        freq.set(prefix, (freq.get(prefix) || 0) + 1);
    }
    return count;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
using System.Collections.Generic;

int SubarraySum(int[] nums, int k) {
    var freq = new Dictionary&lt;int, int&gt;();
    freq[0] = 1;
    int prefix = 0;
    int count = 0;

    foreach (var x in nums) {
        prefix += x;
        int need = prefix - k;
        if (freq.TryGetValue(need, out int c)) {
            count += c;
        }
        freq[prefix] = freq.TryGetValue(prefix, out int cur) ? cur + 1 : 1;
    }
    return count;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
from typing import List, Dict

def subarray_sum(nums: List[int], k: int) -&gt; int:
    count = 0
    prefix = 0
    freq: Dict[int, int] = {0: 1}
    for x in nums:
        prefix += x
        need = prefix - k
        count += freq.get(need, 0)
        freq[prefix] = freq.get(prefix, 0) + 1
    return count</code></pre>
                </div>

                <div class="complexity-note">
                    Each element is processed once with O(1) expected hash operations.  
                    Time: <strong>O(n)</strong>.  
                    Extra space: up to <strong>O(n)</strong> for distinct prefix sums.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 5 - Two-Sum Variants                              -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 5 - Two-Sum Variants: Indices and Uniqueness</h2>
            <p>
                We solve both parts:
            </p>
            <ol>
                <li>Return any valid pair of indices <code>(i, j)</code> such that <code>nums[i] + nums[j] == target</code>.</li>
                <li>Return the number of <strong>unique value pairs</strong> <code>(a, b)</code> such that <code>a + b == target</code>.</li>
            </ol>

            <!-- ================ Part 1: indices ================ -->
            <h3>Part 1 - Return Indices (Any One Pair)</h3>
            <p>
                Use a map from value to index. For each element, check if <code>target - nums[i]</code> is
                already in the map.
            </p>

            <div class="code-example" data-example="s7p5a">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 5A</span>
                        <span class="meta">Two-sum indices using a hash map</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s7p5a">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C (conceptual; needs map from value->index) -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C (conceptual sketch)
//
// For real C code, you would need a hash map from int -&gt; int (value -&gt; index).
// The algorithm is the same as other languages:
//
// for i in [0..n):
//   need = target - nums[i]
//   if need in map: return (map[need], i)
//   map[nums[i]] = i
//
// If no pair exists, return something like (-1, -1).</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
using namespace std;

vector&lt;int&gt; twoSumIndices(const vector&lt;int&gt; &amp;nums, int target) {
    unordered_map&lt;int, int&gt; mp; // value -&gt; index
    for (int i = 0; i &lt; (int)nums.size(); i++) {
        int need = target - nums[i];
        auto it = mp.find(need);
        if (it != mp.end()) {
            return {it-&gt;second, i};
        }
        mp[nums[i]] = i;
    }
    return {}; // no solution
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
import java.util.*;

int[] twoSumIndices(int[] nums, int target) {
    Map&lt;Integer, Integer&gt; mp = new HashMap&lt;&gt;(); // value -&gt; index
    for (int i = 0; i &lt; nums.length; i++) {
        int need = target - nums[i];
        if (mp.containsKey(need)) {
            return new int[]{mp.get(need), i};
        }
        mp.put(nums[i], i);
    }
    return new int[0]; // no solution
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
function twoSumIndices(nums, target) {
    const map = new Map(); // value -&gt; index
    for (let i = 0; i &lt; nums.length; i++) {
        const need = target - nums[i];
        if (map.has(need)) {
            return [map.get(need), i];
        }
        map.set(nums[i], i);
    }
    return []; // no solution
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
using System.Collections.Generic;

int[] TwoSumIndices(int[] nums, int target) {
    var map = new Dictionary&lt;int, int&gt;(); // value -&gt; index
    for (int i = 0; i &lt; nums.Length; i++) {
        int need = target - nums[i];
        if (map.TryGetValue(need, out int j)) {
            return new[] { j, i };
        }
        map[nums[i]] = i;
    }
    return Array.Empty&lt;int&gt;();
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
from typing import List

def two_sum_indices(nums: List[int], target: int) -&gt; List[int]:
    index_of = {}
    for i, x in enumerate(nums):
        need = target - x
        if need in index_of:
            return [index_of[need], i]
        index_of[x] = i
    return []</code></pre>
                </div>

                <div class="complexity-note">
                    Each element is processed once with O(1) expected hash map operations.  
                    Time: <strong>O(n)</strong>.  
                    Extra space: <strong>O(n)</strong> in the worst case for the map.
                </div>
            </div>

            <!-- ================ Part 2: unique pairs ================ -->
            <h3>Part 2 - Count Unique Value Pairs</h3>
            <p>
                Use a set <code>seen</code> for values we have visited, and another set (or encoding) to
                track unique pairs. Always store pairs as <code>(min, max)</code> to avoid double-counting.
            </p>

            <div class="code-example" data-example="s7p5b">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 5B</span>
                        <span class="meta">Count unique value pairs summing to target</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s7p5b">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C (conceptual) -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C (conceptual sketch)
//
// Maintain:
//   HashSet seen;
//   HashSet pairs; // e.g. store pair as (min, max) encoded as a struct or 64-bit key.
//
// For each x in nums:
//   y = target - x
//   if y in seen:
//       a = min(x, y); b = max(x, y);
//       add pair (a, b) to pairs
//   add x to seen
//
// Answer is size(pairs).</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
#include &lt;unordered_set&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

int countUniquePairs(const vector&lt;int&gt; &amp;nums, int target) {
    unordered_set&lt;int&gt; seen;
    unordered_set&lt;string&gt; pairs;

    for (int x : nums) {
        int y = target - x;
        if (seen.count(y)) {
            int a = min(x, y);
            int b = max(x, y);
            string key = to_string(a) + "," + to_string(b);
            pairs.insert(key);
        }
        seen.insert(x);
    }
    return (int)pairs.size();
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
import java.util.*;

int countUniquePairs(int[] nums, int target) {
    Set&lt;Integer&gt; seen = new HashSet&lt;&gt;();
    Set&lt;String&gt; pairs = new HashSet&lt;&gt;();

    for (int x : nums) {
        int y = target - x;
        if (seen.contains(y)) {
            int a = Math.min(x, y);
            int b = Math.max(x, y);
            String key = a + "," + b;
            pairs.add(key);
        }
        seen.add(x);
    }
    return pairs.size();
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
function countUniquePairs(nums, target) {
    const seen = new Set();
    const pairs = new Set(); // store "a,b" with a &lt;= b

    for (const x of nums) {
        const y = target - x;
        if (seen.has(y)) {
            const a = Math.min(x, y);
            const b = Math.max(x, y);
            pairs.add(a + "," + b);
        }
        seen.add(x);
    }
    return pairs.size;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
using System;
using System.Collections.Generic;

int CountUniquePairs(int[] nums, int target) {
    var seen = new HashSet&lt;int&gt;();
    var pairs = new HashSet&lt;string&gt;(); // store "a,b" with a &lt;= b

    foreach (var x in nums) {
        int y = target - x;
        if (seen.Contains(y)) {
            int a = Math.Min(x, y);
            int b = Math.Max(x, y);
            pairs.Add($"{a},{b}");
        }
        seen.Add(x);
    }
    return pairs.Count;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
from typing import List, Set, Tuple

def count_unique_pairs(nums: List[int], target: int) -&gt; int:
    seen: Set[int] = set()
    pairs: Set[Tuple[int, int]] = set()

    for x in nums:
        y = target - x
        if y in seen:
            a = min(x, y)
            b = max(x, y)
            pairs.add((a, b))
        seen.add(x)
    return len(pairs)</code></pre>
                </div>

                <div class="complexity-note">
                    Both sets grow to at most O(n) size.  
                    Time: single pass with O(1) expected hash operations → <strong>O(n)</strong>.  
                    Extra space: <strong>O(n)</strong>.
                </div>
            </div>
        </section>

        <div class="next-section">
            <a href="problems-section7-hash-tables.html">← Back to Section 7 Problem Set</a>
            &nbsp;&nbsp;
            <a href="section10-practice.html">Back to Practice Hub →</a>
        </div>

        <!-- ======================= Understand-the-algorithm templates ======================= -->

        <div class="deep-dive-template" id="understand-s7p1"
            data-title="Step-by-step: First non-repeating character using frequency counts" hidden>
            <p>
                We want the index of the <em>first</em> character that appears exactly once in the string.
                A hash table (or fixed-size array for ASCII) lets us count frequencies in a single pass.
            </p>
            <ol>
                <li>
                    <strong>Two phases, one idea:</strong>
                    <ul>
                        <li>Phase 1: count how many times each character appears.</li>
                        <li>Phase 2: walk the string again and return the first index whose character has count 1.</li>
                    </ul>
                    <p>
                        Separating counting from selection keeps the logic simple and still runs in linear time.
                    </p>
                </li>
                <li>
                    <strong>Phase 1 – build the frequency map:</strong>
                    <p>
                        Initialize a map <code>freq</code> (or an array of size 256 for byte characters).
                        For each character <code>ch</code> in the string:
                    </p>
                    <ul>
                        <li>Increment <code>freq[ch]</code> by 1.</li>
                    </ul>
                    <p>
                        After this pass, <code>freq[ch]</code> tells you exactly how many times <code>ch</code> appears.
                    </p>
                </li>
                <li>
                    <strong>Phase 2 – find the first index with count 1:</strong>
                    <p>
                        Scan the string again from left to right, keeping an index <code>i</code>:
                    </p>
                    <ul>
                        <li>Look up <code>freq[s[i]]</code>.</li>
                        <li>If it is equal to 1, then this is the first non-repeating character; return <code>i</code>.</li>
                    </ul>
                    <p>
                        If you finish the loop without finding any such character, return <code>-1</code> to indicate
                        that there is no non-repeating character.
                    </p>
                </li>
                <li>
                    <strong>Why we need the second pass:</strong>
                    <p>
                        The first pass tells us <em>which</em> characters are unique, but not <em>which one appears first</em>.
                        The second pass preserves the original order and picks the earliest unique character.
                    </p>
                </li>
                <li>
                    <strong>Complexity intuition:</strong>
                    <p>
                        Each character is processed a constant number of times (once in counting, once in checking),
                        so the running time is O(n) where n is the length of the string.
                        The extra space is O(A) where A is the alphabet size (often treated as constant for ASCII/Unicode blocks).
                    </p>
                </li>
            </ol>
        </div>

        <div class="deep-dive-template" id="understand-s7p2"
            data-title="Step-by-step: Grouping anagrams by a shared signature" hidden>
            <p>
                The core question: how can we tell that two words are anagrams using a hash table?
                The trick is to map every anagram group to a common <em>signature</em>.
            </p>
            <ol>
                <li>
                    <strong>What makes two words anagrams?</strong>
                    <ul>
                        <li>They contain exactly the same characters.</li>
                        <li>Each character appears the same number of times in both words.</li>
                        <li>Only the <em>order</em> of characters may differ.</li>
                    </ul>
                </li>
                <li>
                    <strong>Use a canonical representation (signature):</strong>
                    <p>
                        The simplest signature is the sorted version of the string:
                    </p>
                    <ul>
                        <li><code>"eat" → "aet"</code></li>
                        <li><code>"tea" → "aet"</code></li>
                        <li><code>"ate" → "aet"</code></li>
                    </ul>
                    <p>
                        All anagrams of each other sort to the <em>same</em> string. Non-anagrams will usually
                        have different sorted forms.
                    </p>
                </li>
                <li>
                    <strong>Hashing by signature:</strong>
                    <ol>
                        <li>Initialize a map <code>groups</code> from string key → list of original words.</li>
                        <li>For each word <code>s</code>:
                            <ul>
                                <li>Compute <code>key = sorted(s)</code>.</li>
                                <li>Append <code>s</code> to <code>groups[key]</code>.</li>
                            </ul>
                        </li>
                        <li>At the end, each map entry corresponds to one anagram group.</li>
                    </ol>
                </li>
                <li>
                    <strong>Why this is correct:</strong>
                    <p>
                        If two words are anagrams, their sorted forms are identical, so they land in the same bucket.
                        If they are not anagrams, their sorted forms differ in at least one position and thus produce
                        different keys, separating them into different groups.
                    </p>
                </li>
                <li>
                    <strong>Alternative signatures:</strong>
                    <p>
                        Instead of sorting, you can also use a character-count vector (e.g., counts of 26 letters)
                        as the key. This avoids the <code>O(m log m)</code> sorting cost and can run in
                        <code>O(m)</code> per string, at the cost of a slightly more complex key type.
                    </p>
                </li>
                <li>
                    <strong>Complexity intuition:</strong>
                    <p>
                        Let n be the number of words and m the average length.
                        Sorting each word costs <code>O(m log m)</code>, done n times, giving
                        <code>O(n · m log m)</code> time overall. The extra space holds all strings plus their keys,
                        which is <code>O(n · m)</code>.
                    </p>
                </li>
            </ol>
        </div>

        <div class="deep-dive-template" id="understand-s7p3"
            data-title="Step-by-step: Longest consecutive sequence with a hash set" hidden>
            <p>
                We want the length of the longest run of consecutive integers (like 4,5,6,7) in an unsorted array,
                ideally in O(n) time. A hash set lets us test membership in O(1) expected time.
            </p>
            <ol>
                <li>
                    <strong>Put all numbers into a set:</strong>
                    <p>
                        First, insert every number into a hash set <code>S</code>:
                    </p>
                    <ul>
                        <li>This removes duplicates automatically.</li>
                        <li>It lets us ask “is x in the array?” in constant expected time.</li>
                    </ul>
                </li>
                <li>
                    <strong>Only start from sequence beginnings:</strong>
                    <p>
                        For each number <code>x</code> in the set, we ask:
                    </p>
                    <ul>
                        <li>If <code>x - 1</code> is also in the set, then <code>x</code> is in the <em>middle</em>
                            of a sequence starting earlier. We <em>skip</em> it.</li>
                        <li>If <code>x - 1</code> is <em>not</em> in the set, then <code>x</code> might be the
                            <em>start</em> of a new consecutive run.</li>
                    </ul>
                </li>
                <li>
                    <strong>Growing a sequence from each start:</strong>
                    <p>
                        When we find a start <code>x</code> (i.e., <code>x - 1</code> not in <code>S</code>):</p>
                    <ol>
                        <li>Initialize <code>cur = x</code> and <code>length = 1</code>.</li>
                        <li>While <code>cur + 1</code> is in <code>S</code>:
                            <ul>
                                <li>Increment <code>cur</code>.</li>
                                <li>Increment <code>length</code>.</li>
                            </ul>
                        </li>
                        <li>Update the global best length.</li>
                    </ol>
                </li>
                <li>
                    <strong>Why we stay O(n):</strong>
                    <p>
                        Each number is part of exactly one “forward walk” from some sequence start.
                        We never scan backwards, and we never restart a sequence in the middle because we skip
                        numbers that have <code>x - 1</code> in the set. So each value gets visited at most a
                        constant number of times, keeping the total work linear.
                    </p>
                </li>
                <li>
                    <strong>Edge cases:</strong>
                    <ul>
                        <li>Empty array → answer 0.</li>
                        <li>All numbers identical → set has size 1, sequence length 1.</li>
                        <li>Already sorted array → still works in O(n).</li>
                    </ul>
                </li>
                <li>
                    <strong>Complexity intuition:</strong>
                    <p>
                        Building the set is O(n). The scan over the set is O(n), and each inner while loop
                        advances <code>cur</code> at most once per distinct number overall. So the expected time
                        is O(n), with O(n) extra space for the set.
                    </p>
                </li>
            </ol>
        </div>

        <div class="deep-dive-template" id="understand-s7p4"
            data-title="Step-by-step: Subarray sum equals K via prefix sums" hidden>
            <p>
                The goal is to count how many contiguous subarrays sum to <code>k</code> without using a slow
                double loop. Prefix sums plus a frequency map let us do this in one pass.
            </p>
            <ol>
                <li>
                    <strong>Define a prefix sum:</strong>
                    <p>
                        Let <code>prefix[i]</code> be the sum of elements from index 0 through i.
                        Then the sum of a subarray from <code>l</code> to <code>r</code> is:
                    </p>
                    <p>
                        <code>sum(l..r) = prefix[r] - prefix[l - 1]</code> (with <code>prefix[-1] = 0</code>).
                    </p>
                </li>
                <li>
                    <strong>Rewriting the condition:</strong>
                    <p>
                        We want <code>sum(l..r) = k</code>, so:
                    </p>
                    <p>
                        <code>prefix[r] - prefix[l - 1] = k</code> ⇒
                        <code>prefix[l - 1] = prefix[r] - k</code>.
                    </p>
                    <p>
                        For each current prefix sum <code>prefix</code>, any earlier prefix equal to
                        <code>prefix - k</code> gives us a subarray ending here with sum k.
                    </p>
                </li>
                <li>
                    <strong>Using a frequency map:</strong>
                    <ol>
                        <li>Maintain a running <code>prefix</code> sum as you iterate the array.</li>
                        <li>Maintain a map <code>freq</code> where <code>freq[value]</code> is how many times we've
                            seen that prefix sum so far.</li>
                        <li>Initialize <code>freq[0] = 1</code> to handle subarrays that start at index 0.</li>
                        <li>At each new element <code>x</code>:
                            <ul>
                                <li>Update <code>prefix += x</code>.</li>
                                <li>Let <code>need = prefix - k</code>.</li>
                                <li>If <code>need</code> is in the map, add <code>freq[need]</code> to the answer.</li>
                                <li>Then increment <code>freq[prefix]</code> by 1.</li>
                            </ul>
                        </li>
                    </ol>
                </li>
                <li>
                    <strong>Why this counts <em>all</em> subarrays:</strong>
                    <p>
                        At the moment we are at index <code>r</code> with prefix <code>prefix[r]</code>:
                    </p>
                    <ul>
                        <li>Every earlier index <code>l - 1</code> such that
                            <code>prefix[l - 1] = prefix[r] - k</code> gives a valid subarray <code>l..r</code>.</li>
                        <li>The map tells us how many such <code>l - 1</code> indices we have seen.</li>
                    </ul>
                    <p>
                        We add all of them to the count in one step, instead of scanning backwards.
                    </p>
                </li>
                <li>
                    <strong>Initialization detail: prefix 0 appears once:</strong>
                    <p>
                        Setting <code>freq[0] = 1</code> before processing any elements accounts for subarrays
                        that start at index 0. For example, if <code>prefix[r] == k</code>, then
                        <code>need = prefix[r] - k = 0</code>, and this adds 1 to the answer as desired.
                    </p>
                </li>
                <li>
                    <strong>Complexity intuition:</strong>
                    <p>
                        We process each element once, and each step performs O(1) expected hash map operations.
                        This yields O(n) time and O(n) space in the worst case for distinct prefix sums.
                    </p>
                </li>
            </ol>
        </div>

        <div class="deep-dive-template" id="understand-s7p5a"
            data-title="Step-by-step: Two-sum indices using a value→index map" hidden>
            <p>
                We want to find any pair of indices <code>(i, j)</code> such that
                <code>nums[i] + nums[j] == target</code> without using a quadratic double loop.
                A hash map of value → index lets us do this in one pass.
            </p>
            <ol>
                <li>
                    <strong>Rewriting the condition:</strong>
                    <p>
                        For each number <code>x = nums[i]</code>, we want some earlier number <code>y</code> such that:
                    </p>
                    <p>
                        <code>x + y = target</code> ⇒ <code>y = target - x</code>.
                    </p>
                    <p>
                        So whenever we look at <code>x</code>, we should check if we've already seen
                        <code>target - x</code>.
                    </p>
                </li>
                <li>
                    <strong>Using a hash map:</strong>
                    <ol>
                        <li>Initialize an empty map <code>index_of</code> from number → its index.</li>
                        <li>Iterate over indices <code>i</code> from 0 to n - 1:
                            <ul>
                                <li>Let <code>x = nums[i]</code>.</li>
                                <li>Compute <code>need = target - x</code>.</li>
                                <li>
                                    If <code>need</code> is already in <code>index_of</code>, we've found a solution:
                                    <code>(index_of[need], i)</code>.
                                </li>
                                <li>Otherwise, store <code>index_of[x] = i</code> and move on.</li>
                            </ul>
                        </li>
                    </ol>
                </li>
                <li>
                    <strong>Why this is correct:</strong>
                    <p>
                        When we process index <code>i</code>, the map contains all earlier elements at indices
                        <code>&lt; i</code>. If there exists a valid pair <code>(j, i)</code>, then when we reach
                        <code>i</code>, <code>nums[j]</code> is already in the map, and we detect it via
                        <code>need = target - nums[i]</code>.
                    </p>
                </li>
                <li>
                    <strong>Order of insertion matters:</strong>
                    <p>
                        We always check the map <em>before</em> inserting the current element. This ensures we never
                        match an element with itself unless the problem explicitly allows using the same index twice
                        (most two-sum variants do not).
                    </p>
                </li>
                <li>
                    <strong>Handling duplicates:</strong>
                    <p>
                        If the array has duplicates, the map naturally handles them:
                    </p>
                    <ul>
                        <li>For pairs like <code>2 + 2 = 4</code>, the first <code>2</code> gets stored, and when we
                            encounter the second <code>2</code>, we see that <code>need = 2</code> is already present.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Complexity intuition:</strong>
                    <p>
                        Each element is processed once, with O(1) expected map operations (lookup + optional insert).
                        The time is O(n), and the map stores at most n entries, so space is also O(n).
                    </p>
                </li>
            </ol>
        </div>

        <div class="deep-dive-template" id="understand-s7p5b"
            data-title="Step-by-step: Counting unique two-sum value pairs" hidden>
            <p>
                Now we want the number of <em>distinct value pairs</em> <code>(a, b)</code> such that
                <code>a + b == target</code>, regardless of how many times each pair appears in the array.
                We need to avoid double-counting.
            </p>
            <ol>
                <li>
                    <strong>Separate concerns: seen values vs. seen pairs:</strong>
                    <ul>
                        <li><code>seen</code>: a set of values we have visited so far while scanning the array.</li>
                        <li><code>pairs</code>: a set of <em>unique pairs</em> that we have already counted.</li>
                    </ul>
                </li>
                <li>
                    <strong>Single pass over the array:</strong>
                    <ol>
                        <li>For each number <code>x</code> in the array:
                            <ul>
                                <li>Let <code>y = target - x</code>.</li>
                                <li>If <code>y</code> is already in <code>seen</code>, then <code>(x, y)</code> is a
                                    valid two-sum pair.</li>
                                <li>Normalize the pair to avoid order issues:
                                    <code>a = min(x, y)</code>, <code>b = max(x, y)</code>.</li>
                                <li>Insert normalized pair <code>(a, b)</code> into <code>pairs</code>.</li>
                                <li>Regardless, add <code>x</code> to <code>seen</code>.</li>
                            </ul>
                        </li>
                    </ol>
                </li>
                <li>
                    <strong>Why normalization matters:</strong>
                    <p>
                        Without normalization, pairs <code>(2, 5)</code> and <code>(5, 2)</code> would be considered
                        different, even though they represent the same value pair. By always storing
                        <code>(min, max)</code>, we guarantee:
                    </p>
                    <ul>
                        <li>Each unordered pair is represented in exactly one way.</li>
                        <li>Duplicates from different indices collapse into one set entry.</li>
                    </ul>
                </li>
                <li>
                    <strong>Handling duplicates in the input:</strong>
                    <p>
                        Duplicates do not cause double-counting because:
                    </p>
                    <ul>
                        <li>Every time we encounter <code>x</code>, we only form a pair if <code>y</code> has appeared
                            before (in <code>seen</code>).</li>
                        <li>The normalized pair <code>(a, b)</code> is inserted into <code>pairs</code> at most once,
                            since sets ignore repeated insertions.</li>
                    </ul>
                </li>
                <li>
                    <strong>What the final answer represents:</strong>
                    <p>
                        At the end, <code>pairs</code> contains exactly one representative for each distinct value
                        pair that sums to the target. The answer is just <code>size(pairs)</code>.
                    </p>
                </li>
                <li>
                    <strong>Complexity intuition:</strong>
                    <p>
                        We scan the array once and perform O(1) expected operations on the <code>seen</code> and
                        <code>pairs</code> sets per element. This gives O(n) expected time and O(n) extra space in
                        the worst case (when many pairs exist).
                    </p>
                </li>
            </ol>
        </div>

        <!-- ======================= Modal shell reused by all buttons ======================= -->

        <div class="deep-dive-backdrop" id="deep-dive-backdrop" aria-hidden="true">
            <div class="deep-dive-modal" role="dialog" aria-modal="true" aria-labelledby="deep-dive-title">
                <button type="button" class="deep-dive-close" aria-label="Close">&times;</button>
                <h2 id="deep-dive-title">&nbsp;</h2>
                <div class="deep-dive-body"></div>
            </div>
        </div>

    </main>
</body>

</html>
