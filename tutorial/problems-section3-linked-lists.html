<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Problems - Section 3 Linked Lists</title>

    <!-- Site styles -->
    <link rel="stylesheet" href="css/site.css">

    <!-- Highlight.js theme (initial, can be changed via selector) -->
    <link id="hljs-theme" rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

    <!-- highlight.js core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- highlight.js languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

    <!-- Site scripts (tabs, highlight init, prefs, etc.) -->
    <script src="js/site.js"></script>

    <!-- Favicon -->
    <link rel="icon" href="img/icon.svg" type="image/svg+xml" sizes="any">
</head>

<body>
    <main>
        <div class="top-nav">
            <a href="section10-practice.html">← Back to Practice Hub</a>
            &nbsp;&nbsp;
            <a href="section3-linked-lists.html">View Section 3 Lesson →</a>
        </div>

        <div class="kicker">Section 3 - Problem Set</div>
        <h1>Linked Lists</h1>
        <p class="tagline">
            These problems focus on pointer manipulation, list traversal, cycle detection, and common
            interview patterns involving singly linked lists.
        </p>

        <div class="theme-picker">
            <label for="theme-select">Syntax theme:</label>
            <select id="theme-select">
                <option value="atom-one-dark">Dark</option>
                <option value="far">Blue</option>
                <option value="atom-one-light">Light</option>
            </select>
        </div>

        <hr>

        <!-- Problem 1 -->
        <section class="problem">
            <h2>Problem 1 - Basic Singly Linked List Operations</h2>
            <p>
                Assume a singly linked list node structure:
            </p>

<pre><code class="language-c">typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;</code></pre>

            <p>
                Describe how to implement the following operations on a singly linked list:
            </p>
            <ol>
                <li>Insert a new node with value <code>x</code> at the head.</li>
                <li>Insert a new node with value <code>x</code> after a given node <code>p</code>.</li>
                <li>Delete the node immediately after a given node <code>p</code> (if it exists).</li>
            </ol>
            <p>
                You may use pseudocode or any language. For each operation, give the time complexity
                in terms of the number of nodes <code>n</code>.
            </p>

            <details class="practice-details">
                <summary>Hint...</summary>
                <div>
                    For each operation, think about how many pointers you actually need to follow.
                    Head insertion and "insert after" do not require walking the entire list if you
                    already have a pointer to the right place.
                </div>
            </details>

            <details class="practice-details">
                <summary>Show answer...</summary>
                <div>
                    Let <code>head</code> be a pointer to the first node (possibly <code>NULL</code>).
                    <ul>
                        <li>
                            <strong>Insert at head:</strong><br>
<pre><code class="language-c">void insert_head(ListNode** head, int x) {
    ListNode* node = malloc(sizeof(ListNode));
    node-&gt;val = x;
    node-&gt;next = *head;
    *head = node;
}</code></pre>
                            This does a constant amount of work → <strong>O(1)</strong>.
                        </li>
                        <li>
                            <strong>Insert after node p:</strong><br>
<pre><code class="language-c">void insert_after(ListNode* p, int x) {
    if (!p) return;
    ListNode* node = malloc(sizeof(ListNode));
    node-&gt;val = x;
    node-&gt;next = p-&gt;next;
    p-&gt;next = node;
}</code></pre>
                            Again, constant work if you already have <code>p</code> → <strong>O(1)</strong>.
                        </li>
                        <li>
                            <strong>Delete after node p:</strong><br>
<pre><code class="language-c">void delete_after(ListNode* p) {
    if (!p || !p-&gt;next) return;
    ListNode* doomed = p-&gt;next;
    p-&gt;next = doomed-&gt;next;
    free(doomed);
}</code></pre>
                            Also constant work if you already know <code>p</code> → <strong>O(1)</strong>.
                        </li>
                    </ul>
                    In all cases, the time complexity is <strong>O(1)</strong>. No traversal over all
                    <code>n</code> nodes is needed if you already have a pointer to the location.
                </div>
            </details>
        </section>

        <hr>

        <!-- Problem 2 -->
        <section class="problem">
            <h2>Problem 2 - Reverse a Singly Linked List</h2>
            <p>
                Given the head of a singly linked list, reverse the list in-place and return the new head.
            </p>
            <p>
                Example:
            </p>
            <ul>
                <li>Input: <code>1 → 2 → 3 → 4 → NULL</code></li>
                <li>Output: <code>4 → 3 → 2 → 1 → NULL</code></li>
            </ul>
            <p>
                Write an iterative solution and give its time and space complexity.
            </p>

            <details class="practice-details">
                <summary>Hint...</summary>
                <div>
                    Keep three pointers: <code>prev</code>, <code>curr</code>, and <code>next</code>.
                    At each step, redirect <code>curr-&gt;next</code> to <code>prev</code>, then advance.
                </div>
            </details>

            <details class="practice-details">
                <summary>Show answer...</summary>
                <div>
                    One iterative approach (Python):
<pre><code class="language-python">from typing import Optional

class ListNode:
    def __init__(self, val: int = 0, next: "Optional[ListNode]" = None):
        self.val = val
        self.next = next

def reverse_list(head: Optional[ListNode]) -&gt; Optional[ListNode]:
    prev = None
    curr = head
    while curr is not None:
        nxt = curr.next
        curr.next = prev
        prev = curr
        curr = nxt
    return prev</code></pre>
                    Each node is visited once, and the pointer reversal is O(1) work per node.<br>
                    Time: <strong>O(n)</strong> where <code>n</code> is the number of nodes.<br>
                    Extra space: we only use a few pointers → <strong>O(1)</strong>.
                </div>
            </details>
        </section>

        <hr>

        <!-- Problem 3 -->
        <section class="problem">
            <h2>Problem 3 - Detect a Cycle (Floyd&apos;s Tortoise and Hare)</h2>
            <p>
                Given the head of a singly linked list, determine whether the list contains a cycle.
                A cycle exists if some node can be reached again by continuously following
                <code>next</code> pointers.
            </p>
            <p>
                You must use O(1) extra space.
            </p>

            <details class="practice-details">
                <summary>Hint...</summary>
                <div>
                    Use two pointers: one that moves one step at a time and one that moves two steps at a time.
                    If there is a cycle, they will eventually meet.
                </div>
            </details>

            <details class="practice-details">
                <summary>Show answer...</summary>
                <div>
                    Floyd&apos;s cycle detection (Java):
<pre><code class="language-java">class ListNode {
    int val;
    ListNode next;
    ListNode(int v) { val = v; }
}

boolean hasCycle(ListNode head) {
    if (head == null) return false;
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null &amp;&amp; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}</code></pre>
                    Time: both pointers advance through the list; in the worst case they traverse O(n) nodes.
                    Hence time is <strong>O(n)</strong>.<br>
                    Extra space: we use only a few pointers → <strong>O(1)</strong>.
                </div>
            </details>
        </section>

        <hr>

        <!-- Problem 4 -->
        <section class="problem">
            <h2>Problem 4 - Find the Middle of a Linked List</h2>
            <p>
                Given the head of a singly linked list, return the middle node. If there are two middle nodes
                (for even length), return the second one.
            </p>
            <p>
                Example:
            </p>
            <ul>
                <li><code>1 → 2 → 3 → 4 → 5 → NULL</code> → return node with value <code>3</code>.</li>
                <li><code>1 → 2 → 3 → 4 → NULL</code> → return node with value <code>3</code>.</li>
            </ul>

            <details class="practice-details">
                <summary>Hint...</summary>
                <div>
                    Use a slow pointer that moves one step at a time and a fast pointer that moves two steps.
                    When fast reaches the end, slow will be at the middle.
                </div>
            </details>

            <details class="practice-details">
                <summary>Show answer...</summary>
                <div>
                    Example solution (C#):
<pre><code class="language-csharp">class ListNode {
    public int Val;
    public ListNode? Next;
    public ListNode(int val) { Val = val; }
}

ListNode? MiddleNode(ListNode? head) {
    ListNode? slow = head;
    ListNode? fast = head;
    while (fast != null &amp;&amp; fast.Next != null) {
        slow = slow!.Next;
        fast = fast.Next.Next;
    }
    return slow;
}</code></pre>
                    Fast moves two steps and slow moves one. When fast is at the end, slow is at the middle.
                    For even length, slow arrives at the second middle by convention.<br>
                    Time: each pointer advances O(n) steps total → <strong>O(n)</strong>.<br>
                    Extra space: constant → <strong>O(1)</strong>.
                </div>
            </details>
        </section>

        <hr>

        <!-- Problem 5 -->
        <section class="problem">
            <h2>Problem 5 - Merge Two Sorted Linked Lists</h2>
            <p>
                You are given two sorted singly linked lists <code>l1</code> and <code>l2</code> (in non-decreasing order).
                Merge them into a single sorted list and return the head of the merged list. You should reuse the
                existing nodes (no new nodes needed besides maybe a dummy head).
            </p>
            <p>
                Example:
            </p>
            <ul>
                <li><code>l1 = 1 → 3 → 5 → NULL</code></li>
                <li><code>l2 = 2 → 4 → 4 → 6 → NULL</code></li>
                <li>Result: <code>1 → 2 → 3 → 4 → 4 → 5 → 6 → NULL</code></li>
            </ul>

            <details class="practice-details">
                <summary>Hint...</summary>
                <div>
                    Use a dummy node and a tail pointer. At each step, attach the smaller of the two current nodes
                    from <code>l1</code> and <code>l2</code> to the tail, and advance that list.
                </div>
            </details>

            <details class="practice-details">
                <summary>Show answer...</summary>
                <div>
                    Example solution (JavaScript):
<pre><code class="language-javascript">class ListNode {
    constructor(val, next = null) {
        this.val = val;
        this.next = next;
    }
}

function mergeTwoLists(l1, l2) {
    const dummy = new ListNode(0);
    let tail = dummy;

    let a = l1;
    let b = l2;
    while (a !== null &amp;&amp; b !== null) {
        if (a.val &lt;= b.val) {
            tail.next = a;
            a = a.next;
        } else {
            tail.next = b;
            b = b.next;
        }
        tail = tail.next;
    }
    if (a !== null) tail.next = a;
    if (b !== null) tail.next = b;

    return dummy.next;
}</code></pre>
                    Each node is visited exactly once and appended to the merged list.<br>
                    Time: <strong>O(n + m)</strong> where <code>n</code> and <code>m</code> are the lengths of
                    the two lists.<br>
                    Extra space: we only use a few pointers and one dummy node → <strong>O(1)</strong>.
                </div>
            </details>
        </section>

        <hr>

        <!-- Problem 6 -->
        <section class="problem">
            <h2>Problem 6 - Remove N-th Node From the End</h2>
            <p>
                Given the head of a singly linked list and an integer <code>n</code>, remove the
                <code>n</code>-th node from the end of the list and return its head. You should do this in
                one pass if possible.
            </p>
            <p>
                Example:
            </p>
            <ul>
                <li>Input: <code>1 → 2 → 3 → 4 → 5 → NULL</code>, <code>n = 2</code></li>
                <li>Output: <code>1 → 2 → 3 → 5 → NULL</code></li>
            </ul>

            <details class="practice-details">
                <summary>Hint...</summary>
                <div>
                    Use two pointers with a fixed gap of <code>n</code> nodes between them. When the front pointer
                    reaches the end, the back pointer will be just before the node to remove. Consider using
                    a dummy head to handle removing the first real node.
                </div>
            </details>

            <details class="practice-details">
                <summary>Show answer...</summary>
                <div>
                    Example solution (C++):
<pre><code class="language-cpp">struct ListNode {
    int val;
    ListNode* next;
    ListNode(int v) : val(v), next(nullptr) {}
};

ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode dummy(0);
    dummy.next = head;
    ListNode* fast = &dummy;
    ListNode* slow = &dummy;

    // Move fast n+1 steps so the gap between slow and fast is n
    for (int i = 0; i &lt;= n; i++) {
        fast = fast-&gt;next;
    }

    // Move both until fast reaches the end
    while (fast != nullptr) {
        fast = fast-&gt;next;
        slow = slow-&gt;next;
    }

    // slow is now just before the node to delete
    ListNode* doomed = slow-&gt;next;
    slow-&gt;next = doomed-&gt;next;
    delete doomed;

    return dummy.next;
}</code></pre>
                    We traverse the list with <code>fast</code> once and move <code>slow</code> in sync, so we do
                    only a single pass over the list.<br>
                    Time: <strong>O(n)</strong> where <code>n</code> is the number of nodes.<br>
                    Extra space: a few pointers and one dummy node → <strong>O(1)</strong>.
                </div>
            </details>
        </section>

        <div class="next-section">
            <a href="section3-linked-lists.html">
                ← Back to Section 3 Lesson
            </a>
            &nbsp;&nbsp;
            <a href="solutions-section3-linked-lists.html">
                View detailed Solutions
            </a>
            &nbsp;&nbsp;
            <a href="section10-practice.html">
                Back to Practice Hub →
            </a>
        </div>
    </main>
</body>

</html>
