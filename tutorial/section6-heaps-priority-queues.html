<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Section 6 - Heaps &amp; Priority Queues</title>

    <!-- Site styles -->
    <link rel="stylesheet" href="css/site.css">

    <!-- Highlight.js theme (initial, can be changed via selector) -->
    <link id="hljs-theme" rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

    <!-- highlight.js core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- highlight.js languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

    <!-- Site scripts (tab logic, highlight init, localStorage prefs, etc.) -->
    <script src="js/site.js"></script>

    <!-- Favicon -->
    <link rel="icon" href="img/icon.svg" type="image/svg+xml" sizes="any">
</head>

<body>
    <main>
        <div class="top-nav">
            <a href="index.html">← Back to Index</a>
        </div>
        <div class="kicker">Section 6</div>
        <h1>Heaps &amp; Priority Queues</h1>
        <p class="tagline">
            Heaps are tree-based structures that give you fast access to the minimum or maximum element.
            A priority queue uses a heap under the hood to always remove the highest-priority item first.
        </p>

        <h2>
            6.1 What Is a Priority Queue?
            <button type="button" class="deep-dive-trigger" data-deep-id="deep-dive-s6-priority-queue">
                Dig deeper
            </button>
        </h2>
        <p>
            A <strong>priority queue</strong> is an abstract data type that stores items each with a priority,
            and supports operations like:
        </p>
        <ul class="bullet-tight">
            <li><strong>insert(x, priority)</strong> - add a new item.</li>
            <li><strong>find-min / find-max</strong> - peek at the item with best priority.</li>
            <li><strong>extract-min / extract-max</strong> - remove and return that item.</li>
        </ul>
        <p>
            In interview problems, the common implementation is a <strong>binary heap</strong>, which gives:
        </p>
        <ul class="bullet-tight">
            <li><strong>O(log n)</strong> insert</li>
            <li><strong>O(log n)</strong> extract-min / extract-max</li>
            <li><strong>O(1)</strong> peek</li>
        </ul>

        <h2>
            6.2 Binary Heap Basics
            <button type="button" class="deep-dive-trigger" data-deep-id="deep-dive-s6-binary-heap">
                Dig deeper
            </button>
        </h2>
        <p>
            A <strong>binary heap</strong> is a complete binary tree stored in an array, such that:
        </p>
        <ul>
            <li>For a <strong>min-heap</strong>, each node is less than or equal to its children.</li>
            <li>For a <strong>max-heap</strong>, each node is greater than or equal to its children.</li>
            <li>Children of index <code>i</code> are at indices <code>2i + 1</code> and <code>2i + 2</code>
                (0-based indexing).</li>
            <li>The parent of index <code>i</code> is at <code>(i - 1) / 2</code> (integer division).</li>
        </ul>

        <h2>6.3 Code Examples in Multiple Languages</h2>
        <p>
            As before, each example appears in six languages:
            <strong>C, C++, Java, JavaScript, C#,</strong> and <strong>Python</strong>.
            Your theme and language preferences are remembered across sections.
        </p>

        <div class="theme-picker">
            <label for="theme-select">Syntax theme:</label>
            <select id="theme-select">
                <option value="atom-one-dark" selected>Dark</option>
                <option value="far">Blue</option>
                <option value="atom-one-light">Light</option>
            </select>
        </div>

        <hr>

        <!-- ======================= Example 1 ======================= -->
        <h3>
            6.4 Example 1 - Min-Heap Insert (Heapify Up)
            <button type="button" class="deep-dive-trigger inline" data-deep-id="deep-dive-s6-ex1">
                Dig deeper
            </button>
        </h3>
        <p>
            We will implement a simple array-based <strong>min-heap</strong> supporting insertion. After
            we place the new element at the end, we "heapify up" by swapping with its parent while the
            min-heap property is violated.
        </p>

        <div class="code-example" data-example="s6-ex1">
            <div class="code-example-header">
                <div class="code-example-title">
                    <span class="label">Example 1</span>
                    <span class="meta">Insert into a min-heap (heapify up)</span>
                </div>
                <button type="button" class="copy-button" aria-label="Copy code">
                    Copy
                </button>
            </div>

            <div class="tab-bar">
                <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
            </div>

            <div class="code-panel" data-lang-panel="c">
                <pre><code class="language-c">// C
#include &lt;stdbool.h&gt;

#define HEAP_MAX 1024

typedef struct {
    int data[HEAP_MAX];
    int size; // number of elements in heap
} MinHeap;

void heap_init(MinHeap* h) {
    h-&gt;size = 0;
}

static void swap_int(int* a, int* b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

bool heap_insert(MinHeap* h, int value) {
    if (h-&gt;size &gt;= HEAP_MAX) {
        return false; // heap full
    }
    int i = h-&gt;size;
    h-&gt;data[i] = value;
    h-&gt;size++;

    // heapify up
    while (i &gt; 0) {
        int parent = (i - 1) / 2;
        if (h-&gt;data[parent] &lt;= h-&gt;data[i]) {
            break;
        }
        swap_int(&amp;h-&gt;data[parent], &amp;h-&gt;data[i]);
        i = parent;
    }
    return true;
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="cpp">
                <pre><code class="language-cpp">// C++
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

class MinHeap {
public:
    void insert(int value) {
        data_.push_back(value);
        int i = (int)data_.size() - 1;
        // heapify up
        while (i &gt; 0) {
            int parent = (i - 1) / 2;
            if (data_[parent] &lt;= data_[i]) break;
            std::swap(data_[parent], data_[i]);
            i = parent;
        }
    }

private:
    std::vector&lt;int&gt; data_;
};</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="java">
                <pre><code class="language-java">// Java
class MinHeap {
    private java.util.ArrayList&lt;Integer&gt; data = new java.util.ArrayList&lt;&gt;();

    public void insert(int value) {
        data.add(value);
        int i = data.size() - 1;
        // heapify up
        while (i &gt; 0) {
            int parent = (i - 1) / 2;
            if (data.get(parent) &lt;= data.get(i)) break;
            int tmp = data.get(parent);
            data.set(parent, data.get(i));
            data.set(i, tmp);
            i = parent;
        }
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="js">
                <pre><code class="language-javascript">// JavaScript
class MinHeap {
    constructor() {
        this.data = [];
    }

    insert(value) {
        this.data.push(value);
        let i = this.data.length - 1;
        // heapify up
        while (i &gt; 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.data[parent] &lt;= this.data[i]) break;
            [this.data[parent], this.data[i]] = [this.data[i], this.data[parent]];
            i = parent;
        }
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="cs">
                <pre><code class="language-csharp">// C#
using System.Collections.Generic;

class MinHeap {
    private readonly List&lt;int&gt; _data = new List&lt;int&gt;();

    public void Insert(int value) {
        _data.Add(value);
        int i = _data.Count - 1;
        // heapify up
        while (i &gt; 0) {
            int parent = (i - 1) / 2;
            if (_data[parent] &lt;= _data[i]) break;
            int tmp = _data[parent];
            _data[parent] = _data[i];
            _data[i] = tmp;
            i = parent;
        }
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="py">
                <pre><code class="language-python"># Python
class MinHeap:
    def __init__(self) -&gt; None:
        self._data: list[int] = []

    def insert(self, value: int) -&gt; None:
        self._data.append(value)
        i = len(self._data) - 1
        # heapify up
        while i &gt; 0:
            parent = (i - 1) // 2
            if self._data[parent] &lt;= self._data[i]:
                break
            self._data[parent], self._data[i] = self._data[i], self._data[parent]
            i = parent</code></pre>
            </div>

            <div class="complexity-note">
                Time per insert: <strong>O(log n)</strong> in a heap of size <code>n</code>. &nbsp;|&nbsp;
                Extra space: <strong>O(1)</strong> auxiliary (array grows to hold <code>n</code> items).
            </div>
        </div>

        <!-- ======================= Example 2 ======================= -->
        <h3>
            6.5 Example 2 - Extract-Min (Heapify Down)
            <button type="button" class="deep-dive-trigger inline" data-deep-id="deep-dive-s6-ex2">
                Dig deeper
            </button>
        </h3>
        <p>
            To remove the minimum from a min-heap, we swap the root with the last element,
            shrink the heap size, and "heapify down" by swapping the new root with its smaller child
            until the heap property is restored.
        </p>

        <div class="code-example" data-example="s6-ex2">
            <div class="code-example-header">
                <div class="code-example-title">
                    <span class="label">Example 2</span>
                    <span class="meta">Extract minimum and heapify down</span>
                </div>
                <button type="button" class="copy-button" aria-label="Copy code">
                    Copy
                </button>
            </div>

            <div class="tab-bar">
                <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
            </div>

            <div class="code-panel" data-lang-panel="c">
                <pre><code class="language-c">// C
bool heap_extract_min(MinHeap* h, int* out) {
    if (h-&gt;size == 0) {
        return false;
    }
    *out = h-&gt;data[0];
    h-&gt;size--;
    if (h-&gt;size == 0) {
        return true;
    }
    h-&gt;data[0] = h-&gt;data[h-&gt;size];

    int i = 0;
    while (true) {
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        int smallest = i;

        if (left &lt; h-&gt;size &amp;&amp; h-&gt;data[left] &lt; h-&gt;data[smallest]) {
            smallest = left;
        }
        if (right &lt; h-&gt;size &amp;&amp; h-&gt;data[right] &lt; h-&gt;data[smallest]) {
            smallest = right;
        }
        if (smallest == i) break;
        swap_int(&amp;h-&gt;data[i], &amp;h-&gt;data[smallest]);
        i = smallest;
    }
    return true;
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="cpp">
                <pre><code class="language-cpp">// C++
class MinHeapWithExtract {
public:
    void insert(int value) {
        data_.push_back(value);
        int i = (int)data_.size() - 1;
        while (i &gt; 0) {
            int parent = (i - 1) / 2;
            if (data_[parent] &lt;= data_[i]) break;
            std::swap(data_[parent], data_[i]);
            i = parent;
        }
    }

    int extractMin() {
        if (data_.empty()) {
            throw std::runtime_error("heap underflow");
        }
        int minVal = data_.front();
        data_[0] = data_.back();
        data_.pop_back();

        int n = (int)data_.size();
        int i = 0;
        while (true) {
            int left = 2 * i + 1;
            int right = 2 * i + 2;
            int smallest = i;
            if (left &lt; n &amp;&amp; data_[left] &lt; data_[smallest]) {
                smallest = left;
            }
            if (right &lt; n &amp;&amp; data_[right] &lt; data_[smallest]) {
                smallest = right;
            }
            if (smallest == i) break;
            std::swap(data_[i], data_[smallest]);
            i = smallest;
        }
        return minVal;
    }

private:
    std::vector&lt;int&gt; data_;
};</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="java">
                <pre><code class="language-java">// Java
class MinHeapWithExtract {
    private java.util.ArrayList&lt;Integer&gt; data = new java.util.ArrayList&lt;&gt;();

    public void insert(int value) {
        data.add(value);
        int i = data.size() - 1;
        while (i &gt; 0) {
            int parent = (i - 1) / 2;
            if (data.get(parent) &lt;= data.get(i)) break;
            int tmp = data.get(parent);
            data.set(parent, data.get(i));
            data.set(i, tmp);
            i = parent;
        }
    }

    public int extractMin() {
        if (data.isEmpty()) {
            throw new IllegalStateException("heap underflow");
        }
        int minVal = data.get(0);
        int last = data.remove(data.size() - 1);
        if (data.isEmpty()) {
            return minVal;
        }
        data.set(0, last);

        int n = data.size();
        int i = 0;
        while (true) {
            int left = 2 * i + 1;
            int right = 2 * i + 2;
            int smallest = i;
            if (left &lt; n &amp;&amp; data.get(left) &lt; data.get(smallest)) {
                smallest = left;
            }
            if (right &lt; n &amp;&amp; data.get(right) &lt; data.get(smallest)) {
                smallest = right;
            }
            if (smallest == i) break;
            int tmp = data.get(i);
            data.set(i, data.get(smallest));
            data.set(smallest, tmp);
            i = smallest;
        }
        return minVal;
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="js">
                <pre><code class="language-javascript">// JavaScript
class MinHeapWithExtract {
    constructor() {
        this.data = [];
    }

    insert(value) {
        this.data.push(value);
        let i = this.data.length - 1;
        while (i &gt; 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.data[parent] &lt;= this.data[i]) break;
            [this.data[parent], this.data[i]] = [this.data[i], this.data[parent]];
            i = parent;
        }
    }

    extractMin() {
        if (this.data.length === 0) {
            throw new Error("heap underflow");
        }
        const minVal = this.data[0];
        const last = this.data.pop();
        if (this.data.length === 0) {
            return minVal;
        }
        this.data[0] = last;

        const n = this.data.length;
        let i = 0;
        while (true) {
            const left = 2 * i + 1;
            const right = 2 * i + 2;
            let smallest = i;
            if (left &lt; n &amp;&amp; this.data[left] &lt; this.data[smallest]) {
                smallest = left;
            }
            if (right &lt; n &amp;&amp; this.data[right] &lt; this.data[smallest]) {
                smallest = right;
            }
            if (smallest === i) break;
            [this.data[i], this.data[smallest]] = [this.data[smallest], this.data[i]];
            i = smallest;
        }
        return minVal;
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="cs">
                <pre><code class="language-csharp">// C#
using System.Collections.Generic;

class MinHeapWithExtract {
    private readonly List&lt;int&gt; _data = new List&lt;int&gt;();

    public void Insert(int value) {
        _data.Add(value);
        int i = _data.Count - 1;
        while (i &gt; 0) {
            int parent = (i - 1) / 2;
            if (_data[parent] &lt;= _data[i]) break;
            int tmp = _data[parent];
            _data[parent] = _data[i];
            _data[i] = tmp;
            i = parent;
        }
    }

    public int ExtractMin() {
        if (_data.Count == 0) {
            throw new System.InvalidOperationException("heap underflow");
        }
        int minVal = _data[0];
        int last = _data[_data.Count - 1];
        _data.RemoveAt(_data.Count - 1);
        if (_data.Count == 0) {
            return minVal;
        }
        _data[0] = last;

        int n = _data.Count;
        int i = 0;
        while (true) {
            int left = 2 * i + 1;
            int right = 2 * i + 2;
            int smallest = i;
            if (left &lt; n &amp;&amp; _data[left] &lt; _data[smallest]) {
                smallest = left;
            }
            if (right &lt; n &amp;&amp; _data[right] &lt; _data[smallest]) {
                smallest = right;
            }
            if (smallest == i) break;
            int tmp = _data[i];
            _data[i] = _data[smallest];
            _data[smallest] = tmp;
            i = smallest;
        }
        return minVal;
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="py">
                <pre><code class="language-python"># Python
class MinHeapWithExtract:
    def __init__(self) -&gt; None:
        self._data: list[int] = []

    def insert(self, value: int) -&gt; None:
        self._data.append(value)
        i = len(self._data) - 1
        while i &gt; 0:
            parent = (i - 1) // 2
            if self._data[parent] &lt;= self._data[i]:
                break
            self._data[parent], self._data[i] = self._data[i], self._data[parent]
            i = parent

    def extract_min(self) -&gt; int:
        if not self._data:
            raise IndexError("heap underflow")
        min_val = self._data[0]
        last = self._data.pop()
        if not self._data:
            return min_val
        self._data[0] = last

        n = len(self._data)
        i = 0
        while True:
            left = 2 * i + 1
            right = 2 * i + 2
            smallest = i
            if left &lt; n and self._data[left] &lt; self._data[smallest]:
                smallest = left
            if right &lt; n and self._data[right] &lt; self._data[smallest]:
                smallest = right
            if smallest == i:
                break
            self._data[i], self._data[smallest] = self._data[smallest], self._data[i]
            i = smallest
        return min_val</code></pre>
            </div>

            <div class="complexity-note">
                Time per extract-min: <strong>O(log n)</strong> (height of the heap). &nbsp;|&nbsp;
                Extra space: <strong>O(1)</strong> auxiliary.
            </div>
        </div>

        <!-- ======================= Example 3 ======================= -->
        <h3>
            6.6 Example 3 - Build Heap from Array (Heapify)
            <button type="button" class="deep-dive-trigger inline" data-deep-id="deep-dive-s6-ex3">
                Dig deeper
            </button>
        </h3>
        <p>
            Given an array of <code>n</code> elements, we can turn it into a heap in
            <strong>O(n)</strong> time by calling heapify-down from the last parent downward.
        </p>

        <div class="code-example" data-example="s6-ex3">
            <div class="code-example-header">
                <div class="code-example-title">
                    <span class="label">Example 3</span>
                    <span class="meta">Bottom-up heap construction</span>
                </div>
                <button type="button" class="copy-button" aria-label="Copy code">
                    Copy
                </button>
            </div>

            <div class="tab-bar">
                <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
            </div>

            <div class="code-panel" data-lang-panel="c">
                <pre><code class="language-c">// C
static void heapify_down_array(int data[], int n, int i) {
    while (1) {
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        int smallest = i;

        if (left &lt; n &amp;&amp; data[left] &lt; data[smallest]) {
            smallest = left;
        }
        if (right &lt; n &amp;&amp; data[right] &lt; data[smallest]) {
            smallest = right;
        }
        if (smallest == i) break;
        swap_int(&amp;data[i], &amp;data[smallest]);
        i = smallest;
    }
}

void build_min_heap(int data[], int n) {
    for (int i = (n / 2) - 1; i &gt;= 0; i--) {
        heapify_down_array(data, n, i);
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="cpp">
                <pre><code class="language-cpp">// C++
void heapifyDownArray(std::vector&lt;int&gt;&amp; a, int n, int i) {
    while (true) {
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        int smallest = i;
        if (left &lt; n &amp;&amp; a[left] &lt; a[smallest]) smallest = left;
        if (right &lt; n &amp;&amp; a[right] &lt; a[smallest]) smallest = right;
        if (smallest == i) break;
        std::swap(a[i], a[smallest]);
        i = smallest;
    }
}

void buildMinHeap(std::vector&lt;int&gt;&amp; a) {
    int n = (int)a.size();
    for (int i = n / 2 - 1; i &gt;= 0; i--) {
        heapifyDownArray(a, n, i);
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="java">
                <pre><code class="language-java">// Java
void heapifyDownArray(int[] a, int n, int i) {
    while (true) {
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        int smallest = i;
        if (left &lt; n &amp;&amp; a[left] &lt; a[smallest]) smallest = left;
        if (right &lt; n &amp;&amp; a[right] &lt; a[smallest]) smallest = right;
        if (smallest == i) break;
        int tmp = a[i];
        a[i] = a[smallest];
        a[smallest] = tmp;
        i = smallest;
    }
}

void buildMinHeap(int[] a) {
    int n = a.length;
    for (int i = n / 2 - 1; i &gt;= 0; i--) {
        heapifyDownArray(a, n, i);
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="js">
                <pre><code class="language-javascript">// JavaScript
function heapifyDownArray(a, n, i) {
    while (true) {
        const left = 2 * i + 1;
        const right = 2 * i + 2;
        let smallest = i;
        if (left &lt; n &amp;&amp; a[left] &lt; a[smallest]) smallest = left;
        if (right &lt; n &amp;&amp; a[right] &lt; a[smallest]) smallest = right;
        if (smallest === i) break;
        [a[i], a[smallest]] = [a[smallest], a[i]];
        i = smallest;
    }
}

function buildMinHeap(a) {
    const n = a.length;
    for (let i = Math.floor(n / 2) - 1; i &gt;= 0; i--) {
        heapifyDownArray(a, n, i);
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="cs">
                <pre><code class="language-csharp">// C#
void HeapifyDownArray(int[] a, int n, int i) {
    while (true) {
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        int smallest = i;
        if (left &lt; n &amp;&amp; a[left] &lt; a[smallest]) smallest = left;
        if (right &lt; n &amp;&amp; a[right] &lt; a[smallest]) smallest = right;
        if (smallest == i) break;
        int tmp = a[i];
        a[i] = a[smallest];
        a[smallest] = tmp;
        i = smallest;
    }
}

void BuildMinHeap(int[] a) {
    int n = a.Length;
    for (int i = n / 2 - 1; i &gt;= 0; i--) {
        HeapifyDownArray(a, n, i);
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="py">
                <pre><code class="language-python"># Python
def heapify_down_array(a: list[int], n: int, i: int) -&gt; None:
    while True:
        left = 2 * i + 1
        right = 2 * i + 2
        smallest = i
        if left &lt; n and a[left] &lt; a[smallest]:
            smallest = left
        if right &lt; n and a[right] &lt; a[smallest]:
            smallest = right
        if smallest == i:
            break
        a[i], a[smallest] = a[smallest], a[i]
        i = smallest

def build_min_heap(a: list[int]) -&gt; None:
    n = len(a)
    for i in range(n // 2 - 1, -1, -1):
        heapify_down_array(a, n, i)</code></pre>
            </div>

            <div class="complexity-note">
                Time: <strong>O(n)</strong> to build a heap from <code>n</code> items. &nbsp;|&nbsp;
                Extra space: <strong>O(1)</strong> beyond the array.
            </div>
        </div>

        <!-- ======================= Example 4 ======================= -->
        <h3>
            6.7 Example 4 - Heapsort (Concept)
            <button type="button" class="deep-dive-trigger inline" data-deep-id="deep-dive-s6-ex4">
                Dig deeper
            </button>
        </h3>
        <p>
            Heapsort uses a heap to sort an array in-place:
        </p>
        <ul>
            <li>Build a heap from the array.</li>
            <li>Repeatedly extract the min (or max) and place it at the end.</li>
        </ul>
        <p>
            Here we show a min-heap version that produces the array in descending order; using a max-heap
            gives ascending order.
        </p>

        <div class="code-example" data-example="s6-ex4">
            <div class="code-example-header">
                <div class="code-example-title">
                    <span class="label">Example 4</span>
                    <span class="meta">Heapsort with a min-heap</span>
                </div>
                <button type="button" class="copy-button" aria-label="Copy code">
                    Copy
                </button>
            </div>

            <div class="tab-bar">
                <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
            </div>

            <div class="code-panel" data-lang-panel="c">
                <pre><code class="language-c">// C
// Using build_min_heap and heapify_down_array from above.
// Heapsort with a min-heap produces descending order.
void heapsort_desc_minheap(int a[], int n) {
    build_min_heap(a, n);
    for (int end = n - 1; end &gt; 0; end--) {
        swap_int(&amp;a[0], &amp;a[end]);      // move min to end
        heapify_down_array(a, end, 0);  // restore heap on prefix [0, end)
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="cpp">
                <pre><code class="language-cpp">// C++
void heapsortDescMinHeap(std::vector&lt;int&gt;&amp; a) {
    buildMinHeap(a);
    for (int end = (int)a.size() - 1; end &gt; 0; end--) {
        std::swap(a[0], a[end]);
        heapifyDownArray(a, end, 0);
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="java">
                <pre><code class="language-java">// Java
void heapsortDescMinHeap(int[] a) {
    buildMinHeap(a);
    for (int end = a.length - 1; end &gt; 0; end--) {
        int tmp = a[0];
        a[0] = a[end];
        a[end] = tmp;
        heapifyDownArray(a, end, 0);
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="js">
                <pre><code class="language-javascript">// JavaScript
function heapsortDescMinHeap(a) {
    buildMinHeap(a);
    for (let end = a.length - 1; end &gt; 0; end--) {
        [a[0], a[end]] = [a[end], a[0]];
        heapifyDownArray(a, end, 0);
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="cs">
                <pre><code class="language-csharp">// C#
void HeapsortDescMinHeap(int[] a) {
    BuildMinHeap(a);
    for (int end = a.Length - 1; end &gt; 0; end--) {
        int tmp = a[0];
        a[0] = a[end];
        a[end] = tmp;
        HeapifyDownArray(a, end, 0);
    }
}</code></pre>
            </div>

            <div class="code-panel" data-lang-panel="py">
                <pre><code class="language-python"># Python
def heapsort_desc_minheap(a: list[int]) -&gt; None:
    build_min_heap(a)
    for end in range(len(a) - 1, 0, -1):
        a[0], a[end] = a[end], a[0]
        heapify_down_array(a, end, 0)</code></pre>
            </div>

            <div class="complexity-note">
                Time: <strong>O(n log n)</strong> — <code>O(n)</code> to build the heap and
                <code>O(log n)</code> per extraction. &nbsp;|&nbsp;
                Extra space: <strong>O(1)</strong> in-place (ignoring recursion if used).
            </div>
        </div>

        <h2>6.8 Quick Practice</h2>
        <p>For each of these, identify the time and space complexity in terms of <code>n</code>:</p>
        <ol>
            <li>
                Insert <code>n</code> items one by one into an empty min-heap.<br>
                <details class="practice-details">
                    <summary>Show answer...</summary>
                    <div>
                        <strong>1.</strong> Each insert is <strong>O(log n)</strong> in the worst case.<br>
                        Total time: <strong>O(n log n)</strong>.<br>
                        Extra space: <strong>O(n)</strong> for the heap.
                    </div>
                </details>
            </li>
            <li>
                Build a heap from an existing array using the bottom-up heapify algorithm.<br>
                <details class="practice-details">
                    <summary>Show answer...</summary>
                    <div>
                        <strong>2.</strong> The total work of heapifying from the bottom up is <strong>O(n)</strong>.<br>
                        Extra space: <strong>O(1)</strong> beyond the array.
                    </div>
                </details>
            </li>
            <li>
                Repeatedly extract-min from a heap of size <code>n</code> until it is empty.<br>
                <details class="practice-details">
                    <summary>Show answer...</summary>
                    <div>
                        <strong>3.</strong> Each extract-min is <strong>O(log n)</strong>, and there are <code>n</code> of them.<br>
                        Total time: <strong>O(n log n)</strong>.<br>
                        Extra space: <strong>O(1)</strong> auxiliary.
                    </div>
                </details>
            </li>
            <li>
                Implement Dijkstra's shortest path algorithm using a binary heap priority queue on a graph
                with <code>n</code> nodes and <code>m</code> edges.<br>
                <details class="practice-details">
                    <summary>Show answer...</summary>
                    <div>
                        <strong>4.</strong> Each edge may trigger a decrease-key-like operation (or reinsert)
                        and each extract-min is <strong>O(log n)</strong>.<br>
                        Time: <strong>O((n + m) log n)</strong> in the typical adjacency-list formulation.<br>
                        Extra space: <strong>O(n)</strong> for distances and heap entries.
                    </div>
                </details>
            </li>
            <li>
                Compare using a heap-based priority queue vs. an unsorted array when you have many extract-min
                operations and relatively few insertions. Which is better and why?<br>
                <details class="practice-details">
                    <summary>Show answer...</summary>
                    <div>
                        <strong>5.</strong> In an unsorted array, insert is <strong>O(1)</strong> but extract-min is
                        <strong>O(n)</strong>. In a heap, both insert and extract-min are <strong>O(log n)</strong>.<br>
                        If you perform many extract-min operations, the heap is usually better overall because
                        it avoids scanning all <code>n</code> elements each time you remove the minimum.
                    </div>
                </details>
            </li>
        </ol>

        <div class="top-nav">
            <a href="problems-section6-heaps.html">
                Problem Set for Section 6 Heaps &amp; Priority Queues →
            </a>
        </div>
        <div class="next-section">
            <a href="section5-trees-graphs.html">
                ← Back to Section 5
            </a>
            &nbsp;&nbsp;
            <a href="section7-hash-tables.html">
                Next: Section 7 — Hash Tables →
            </a>
        </div>

        <!-- ======================= Deep dive templates ======================= -->

        <div class="deep-dive-template" id="deep-dive-s6-priority-queue"
            data-title="How priority queues differ from regular queues" hidden>
            <p>
                A regular queue is strictly first-in, first-out: the oldest item is always removed next.
                A <strong>priority queue</strong> instead removes the item with the <em>best</em> priority:
                often the smallest number (min-heap) or the largest number (max-heap).
            </p>
            <p>
                Common use cases:
            </p>
            <ul>
                <li><strong>Scheduling:</strong> run the task with the earliest deadline or highest priority first.</li>
                <li><strong>Graph algorithms:</strong> Dijkstra's shortest path, Prim's MST, A* search.</li>
                <li><strong>Streaming problems:</strong> maintain the top-k or bottom-k elements seen so far.</li>
            </ul>
            <p>
                In many languages, the “priority queue” library class is actually a binary heap under the hood,
                which is why the standard operations have <strong>O(log n)</strong> cost.
            </p>
        </div>

        <div class="deep-dive-template" id="deep-dive-s6-binary-heap"
            data-title="Binary heaps and their array layout" hidden>
            <p>
                The key trick with binary heaps is that you do not store explicit left/right pointers:
                the tree structure is <strong>implicit</strong> in the array indices.
            </p>
            <ul>
                <li>Index <code>0</code> is the root.</li>
                <li>Children of <code>i</code> are <code>2i + 1</code> (left) and <code>2i + 2</code> (right).</li>
                <li>The parent of <code>i</code> is <code>(i - 1) / 2</code> (integer division).</li>
            </ul>
            <p>
                Because the tree is <strong>complete</strong> (filled level by level), the array has no gaps
                and the height is <code>O(log n)</code>. That is why heapify-up and heapify-down only need a
                logarithmic number of steps.
            </p>
            <p>
                This layout is cache-friendly and simple to store, which makes binary heaps both fast and easy
                to implement in practice compared to pointer-heavy tree structures.
            </p>
        </div>

        <div class="deep-dive-template" id="deep-dive-s6-ex1"
            data-title="Reasoning about heapify up" hidden>
            <p>
                The heapify-up (percolate-up) operation maintains one crucial invariant:
            </p>
            <ul>
                <li>Before we insert the new element, the array already represents a valid heap.</li>
                <li>After placing the new element at the end, the heap property might be violated only
                    along the path from that index up to the root.</li>
            </ul>
            <p>
                So we repeatedly:
            </p>
            <ol>
                <li>Compare the node with its parent.</li>
                <li>If the node is “better” (smaller for a min-heap), swap them.</li>
                <li>Move the index up to the parent and continue.</li>
            </ol>
            <p>
                Once the parent is no longer worse than the child (or we reach the root), the heap property is
                restored everywhere, because all other parts of the tree were unchanged and already valid.
            </p>
        </div>

        <div class="deep-dive-template" id="deep-dive-s6-ex2"
            data-title="Reasoning about heapify down" hidden>
            <p>
                Heapify-down is the mirror image of heapify-up:
            </p>
            <ul>
                <li>We start with a possible violation at the root (after swapping in the last element).</li>
                <li>Everywhere else below is still a valid heap.</li>
            </ul>
            <p>
                The repair strategy:
            </p>
            <ol>
                <li>Look at the node and its children.</li>
                <li>Swap with the “better” child (smaller for min-heap) if needed.</li>
                <li>Move down to that child and continue.</li>
            </ol>
            <p>
                Because we always push a too-large root downwards, and subtrees are already heaps, the violation
                can only move down one path, giving the <code>O(log n)</code> bound.
            </p>
        </div>

        <div class="deep-dive-template" id="deep-dive-s6-ex3"
            data-title="Why bottom-up heap construction is O(n)" hidden>
            <p>
                At first glance, calling heapify-down on about <code>n/2</code> nodes might look like
                <code>O(n log n)</code>, but most of those calls are on nodes near the leaves and have
                very shallow subtrees.
            </p>
            <p>
                Intuitively:
            </p>
            <ul>
                <li>Half the nodes are leaves and need <strong>O(1)</strong> work.</li>
                <li>A quarter of the nodes are one level up and might move down at most one step.</li>
                <li>An eighth are two levels up, and so on.</li>
            </ul>
            <p>
                If you sum “number of nodes at height h × cost O(h)”, the series converges to a linear amount
                of work, giving the <strong>O(n)</strong> build time that makes heaps very efficient to initialize.
            </p>
        </div>

        <div class="deep-dive-template" id="deep-dive-s6-ex4"
            data-title="Heapsort vs. other O(n log n) sorts" hidden>
            <p>
                Heapsort has a few notable properties:
            </p>
            <ul>
                <li><strong>Time:</strong> <code>O(n log n)</code> in the worst case (no bad pivot cases like naive quicksort).</li>
                <li><strong>Space:</strong> in-place <code>O(1)</code> extra memory.</li>
                <li><strong>Not stable:</strong> equal elements may change relative order.</li>
            </ul>
            <p>
                Compared to other popular algorithms:
            </p>
            <ul>
                <li><strong>Mergesort:</strong> also <code>O(n log n)</code>, stable, but typically needs
                    <code>O(n)</code> extra space.</li>
                <li><strong>Quicksort:</strong> excellent average performance and cache behavior, but has a
                    worst case worse than heapsort unless carefully implemented.</li>
            </ul>
            <p>
                In interviews, understanding heapsort reinforces your intuition about heaps: every extraction
                pulls off the next smallest (or largest) element, and the array gradually divides into a heap
                prefix and a sorted suffix.
            </p>
        </div>

        <!-- ======================= Deep dive modal shell ======================= -->

        <div class="deep-dive-backdrop" id="deep-dive-backdrop" aria-hidden="true">
            <div class="deep-dive-modal" role="dialog" aria-modal="true" aria-labelledby="deep-dive-title">
                <button type="button" class="deep-dive-close" aria-label="Close">&times;</button>
                <h2 id="deep-dive-title">&nbsp;</h2>
                <div class="deep-dive-body"></div>
            </div>
        </div>

    </main>
</body>

</html>
