<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Problems - Section 9 Advanced DP Patterns</title>

    <!-- Site styles -->
    <link rel="stylesheet" href="css/site.css">

    <!-- Highlight.js theme -->
    <link id="hljs-theme" rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

    <!-- highlight.js core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- highlight.js languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

    <!-- Site scripts -->
    <script src="js/site.js"></script>
    <link rel="icon" href="img/icon.svg" type="image/svg+xml" sizes="any">
</head>

<body>
    <main>
        <div class="top-nav">
            <a href="section10-practice.html">← Back to Practice Hub</a>
            &nbsp;&nbsp;
            <a href="section9-advanced-dp.html">View Section 9 Lesson →</a>
        </div>

        <div class="kicker">Section 9 - Problem Set</div>
        <h1>Advanced DP Patterns</h1>
        <p class="tagline">
            These problems cover LIS, 0/1 knapsack, subset and partition DP, bitmask DP,
            and interval-style DP recurrences.
        </p>

        <div class="theme-picker">
            <label for="theme-select">Syntax theme:</label>
            <select id="theme-select">
                <option value="atom-one-dark">Dark</option>
                <option value="far">Blue</option>
                <option value="atom-one-light">Light</option>
            </select>
        </div>

        <hr>

        <!-- Problem 1 -->
        <section class="problem">
            <h2>Problem 1 - Longest Increasing Subsequence (O(n log n))</h2>
            <p>
                Given an integer array <code>nums</code>, return the length of the longest strictly increasing
                subsequence.
            </p>
            <p>
                Implement the <strong>O(n log n)</strong> solution using a helper array and binary search
                (sometimes called the "patience sorting" method).
            </p>

            <details class="practice-details">
                <summary>Hint...</summary>
                <div>
                    Maintain an array <code>tails</code> where <code>tails[len]</code> is the smallest possible
                    tail value of an increasing subsequence of length <code>len + 1</code>.  
                    For each number <code>x</code>, binary search the position in <code>tails</code>.
                </div>
            </details>

            <details class="practice-details">
                <summary>Show answer...</summary>
                <div>
                    Example (C++):
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

int lengthOfLIS(const vector&lt;int&gt;&amp; nums) {
    vector&lt;int&gt; tails;
    for (int x : nums) {
        auto it = lower_bound(tails.begin(), tails.end(), x);
        if (it == tails.end()) {
            tails.push_back(x);
        } else {
            *it = x;
        }
    }
    return (int)tails.size();
}</code></pre>
                    Each element performs a binary search on <code>tails</code>, which has length at most n.  
                    Time: <strong>O(n log n)</strong>.<br>
                    Space: <strong>O(n)</strong>.
                </div>
            </details>
        </section>

        <hr>

        <!-- Problem 2 -->
        <section class="problem">
            <h2>Problem 2 - 0/1 Knapsack (Classic DP)</h2>
            <p>
                You have <code>n</code> items, each with <code>value[i]</code> and <code>weight[i]</code>.  
                A knapsack can carry total weight at most <code>W</code>.  
                Maximize the total value without exceeding <code>W</code>.
            </p>

            <details class="practice-details">
                <summary>Hint...</summary>
                <div>
                    Let <code>dp[w]</code> be the maximum value achievable with capacity <code>w</code>.
                    Iterate over items, and for each item, update <code>dp</code> backwards on <code>w</code>
                    to avoid reusing the same item multiple times.
                </div>
            </details>

            <details class="practice-details">
                <summary>Show answer...</summary>
                <div>
                    1D bottom-up (Python):
<pre><code class="language-python">def knapSack(W, weight, value):
    n = len(weight)
    dp = [0] * (W + 1)
    for i in range(n):
        w_i = weight[i]
        v_i = value[i]
        for w in range(W, w_i - 1, -1):
            dp[w] = max(dp[w], dp[w - w_i] + v_i)
    return dp[W]</code></pre>
                    Time: for <code>n</code> items and capacity <code>W</code>, complexity is <strong>O(n W)</strong>.<br>
                    Space: <strong>O(W)</strong>.
                </div>
            </details>
        </section>

        <hr>

        <!-- Problem 3 -->
        <section class="problem">
            <h2>Problem 3 - Partition Equal Subset Sum</h2>
            <p>
                Given a set of positive integers <code>nums</code>, determine if it can be partitioned
                into two subsets with equal sum.
            </p>

            <details class="practice-details">
                <summary>Hint...</summary>
                <div>
                    Let <code>total</code> be the sum. If <code>total</code> is odd, answer is false.  
                    Target is <code>total / 2</code>.  
                    Reduce to subset-sum: can we pick a subset that sums to <code>target</code>?
                </div>
            </details>

            <details class="practice-details">
                <summary>Show answer...</summary>
                <div>
                    Boolean DP (Java):
<pre><code class="language-java">boolean canPartition(int[] nums) {
    int total = 0;
    for (int x : nums) total += x;
    if (total % 2 != 0) return false;
    int target = total / 2;

    boolean[] dp = new boolean[target + 1];
    dp[0] = true;

    for (int x : nums) {
        for (int s = target; s &gt;= x; s--) {
            if (dp[s - x]) dp[s] = true;
        }
    }
    return dp[target];
}</code></pre>
                    Time: <strong>O(n * target)</strong> where <code>target = total / 2</code>.<br>
                    Space: <strong>O(target)</strong>.
                </div>
            </details>
        </section>

        <hr>

        <!-- Problem 4 -->
        <section class="problem">
            <h2>Problem 4 - Bitmask DP: Traveling Over Subsets</h2>
            <p>
                You are given a cost matrix <code>cost[i][j]</code> representing the cost to go from city
                <code>i</code> to city <code>j</code>. Starting at city 0, you want to visit each city exactly once
                and return to city 0. This is the Traveling Salesman Problem (TSP) variant for small <code>n</code>.
            </p>
            <p>
                Describe a DP over subsets solution and give its time complexity (in terms of <code>n</code>).
                You do not need to write full code, but giving a function signature and recurrence is helpful.
            </p>

            <details class="practice-details">
                <summary>Hint...</summary>
                <div>
                    Let state be <code>(mask, i)</code> where:
                    <ul>
                        <li><code>mask</code> is a bitmask of visited cities.</li>
                        <li><code>i</code> is the current city.</li>
                    </ul>
                    DP value is the minimum cost to have visited exactly <code>mask</code> and end at <code>i</code>.
                </div>
            </details>

            <details class="practice-details">
                <summary>Show answer...</summary>
                <div>
                    Typical recurrence:
<pre><code class="language-text">dp[mask][i] = min over j in mask, j != i of
              dp[mask without i][j] + cost[j][i]</code></pre>

                    Conceptual pseudocode (C-like):
<pre><code class="language-c">int dp[1 &lt;&lt; N][N]; // initialize to large INF

// Base: only city 0 visited, at city 0
dp[1 &lt;&lt; 0][0] = 0;

for (int mask = 0; mask &lt; (1 &lt;&lt; N); mask++) {
    for (int i = 0; i &lt; N; i++) {
        if (!(mask &amp; (1 &lt;&lt; i))) continue; // i not in mask
        int prevMask = mask ^ (1 &lt;&lt; i);
        if (prevMask == 0 &amp;&amp; i == 0) continue;
        // transition from j to i
        for (int j = 0; j &lt; N; j++) {
            if (!(prevMask &amp; (1 &lt;&lt; j))) continue;
            dp[mask][i] = min(dp[mask][i],
                              dp[prevMask][j] + cost[j][i]);
        }
    }
}

// answer: min over i of dp[allVisited][i] + cost[i][0]</code></pre>
                    There are <code>2^n</code> masks and <code>n</code> possible endings per mask, and each transition
                    loops over up to <code>n</code> previous cities.<br>
                    Time: <strong>O(n² 2^n)</strong>.<br>
                    Space: <strong>O(n 2^n)</strong>.
                </div>
            </details>
        </section>

        <hr>

        <!-- Problem 5 -->
        <section class="problem">
            <h2>Problem 5 - Interval DP: Minimum Cost to Cut a Stick</h2>
            <p>
                You have a stick of length <code>n</code>, and an array <code>cuts</code> of positions where you must
                cut the stick. Cutting the stick of length <code>L</code> costs <code>L</code> units.
                After each cut, the stick is split and further cuts cost based on the local piece lengths.
                Compute the minimum total cost to perform all cuts.
            </p>

            <details class="practice-details">
                <summary>Hint...</summary>
                <div>
                    Sort the cut positions, and add implicit boundaries at <code>0</code> and <code>n</code>.  
                    Let <code>dp[i][j]</code> be the minimum cost to cut between cuts <code>i</code> and <code>j</code>
                    (exclusive of boundaries, inclusive in indices).
                    Try all possible first cuts between <code>i</code> and <code>j</code>.
                </div>
            </details>

            <details class="practice-details">
                <summary>Show answer...</summary>
                <div>
                    Example (Python):
<pre><code class="language-python">def minCost(n, cuts):
    cuts = sorted(cuts)
    cuts = [0] + cuts + [n]
    m = len(cuts)
    dp = [[0] * m for _ in range(m)]

    # length is interval size in terms of indices
    for length in range(2, m):  # at least 2 apart
        for i in range(0, m - length):
            j = i + length
            best = float("inf")
            for k in range(i + 1, j):
                cost = dp[i][k] + dp[k][j] + (cuts[j] - cuts[i])
                if cost &lt; best:
                    best = cost
            dp[i][j] = 0 if best == float("inf") else best
    return dp[0][m - 1]</code></pre>
                    We consider all intervals and all possible split points inside each interval.<br>
                    If there are <code>m</code> cut points (including boundaries), time is <strong>O(m³)</strong> in worst case.<br>
                    Space: DP table <code>m * m</code> → <strong>O(m²)</strong>.
                </div>
            </details>
        </section>

        <div class="next-section">
            <a href="section9-advanced-dp.html">← Back to Section 9 Lesson</a>
            &nbsp;&nbsp;
            <a href="solutions-section9-advanced-dp.html">
                View detailed Solutions
            </a>
            &nbsp;&nbsp;
            <a href="section10-practice.html">Back to Practice Hub →</a>
        </div>
    </main>
</body>

</html>
