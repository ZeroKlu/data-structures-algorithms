<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Section 13 - Tries (Prefix Trees)</title>

    <!-- Site styles -->
    <link rel="stylesheet" href="css/site.css">

    <!-- Highlight.js theme (initial, can be changed via selector) -->
    <link id="hljs-theme" rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

    <!-- highlight.js core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- highlight.js languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

    <!-- Site scripts (tab logic, highlight init, prefs, etc.) -->
    <script src="js/site.js"></script>

    <!-- Favicon -->
    <link rel="icon" href="img/icon.svg" type="image/svg+xml" sizes="any">
</head>

<body>
    <main>
        <div class="top-nav">
            <a href="index.html">← Back to Index</a>
        </div>

        <div class="kicker">Section 13</div>
        <h1>Tries (Prefix Trees)</h1>
        <p class="tagline">
            Learn how <strong>tries</strong> (prefix trees) store and search strings character-by-character,
            enabling fast prefix queries, dictionaries, and autocomplete-style problems.
        </p>

        <div class="theme-picker">
            <label for="theme-select">Syntax theme:</label>
            <select id="theme-select">
                <option value="atom-one-dark">Dark</option>
                <option value="far">Blue</option>
                <option value="atom-one-light">Light</option>
            </select>
        </div>

        <hr>

        <!-- ======================= 13.1 What is a Trie? ======================= -->
        <h2>
            13.1 What is a Trie?
            <button type="button" class="deep-dive-trigger" data-deep-id="deep-dive-s13-what-is-trie">
                Dig deeper
            </button>
        </h2>
        <p>
            A <strong>trie</strong> (pronounced &ldquo;try&rdquo;) is a tree-based data structure that stores
            strings by their <em>prefixes</em>. Each edge represents a character, and each path from the root
            down represents a prefix of one or more stored words.
        </p>
        <ul class="bullet-tight">
            <li>Each node has up to <code>alphabet_size</code> children (e.g., 26 for lowercase English letters).</li>
            <li>We mark nodes where a complete word ends (e.g., with a boolean flag or <code>word_count</code>).</li>
            <li>
                To insert or search you walk the tree <strong>one character at a time</strong> from the root.
            </li>
        </ul>

        <div class="callout">
            <strong>Mental model:</strong> instead of storing whole strings in a flat structure,
            a trie <em>shares prefixes</em>. Words like <code>car</code>, <code>card</code>, and <code>care</code>
            share the path <code>c → a → r</code>.
        </div>

        <hr>

        <!-- ======================= 13.2 Core Operations ======================= -->
        <h2>
            13.2 Core Operations on a Trie
            <button type="button" class="deep-dive-trigger inline" data-deep-id="deep-dive-s13-core-ops">
                Dig deeper
            </button>
        </h2>
        <p>
            Most interview problems that involve tries rely on a few standard operations:
        </p>
        <ul>
            <li><strong>Insert</strong> a word: walk characters, create nodes as needed, mark the final node as a word.</li>
            <li><strong>Search</strong> for a word: walk characters; if any link is missing, the word isn&apos;t present.</li>
            <li>
                <strong>Prefix check</strong> (e.g., <code>startsWith</code>):
                walk characters; if you reach the end of the prefix, it exists as a prefix.
            </li>
            <li>
                Optionally: <strong>delete</strong> a word: unmark the final node and clean up nodes that are no longer used.
            </li>
        </ul>

        <hr>

        <!-- ======================= Example 1 - Basic Trie ======================= -->
        <h3>
            13.3 Example 1 - Basic Trie with Insert and Search
            <button type="button" class="deep-dive-trigger inline" data-deep-id="deep-dive-s13-ex1">
                Dig deeper
            </button>
            <button type="button" class="understand-trigger inline" data-understand-id="understand-s13-ex1">
                Understand the algorithm
            </button>
        </h3>
        <p>
            We implement a trie supporting three operations:
            <code>insert(word)</code>, <code>search(word)</code>, and <code>startsWith(prefix)</code>.
            For simplicity, we assume <strong>lowercase English letters</strong> <code>'a'..'z'</code>.
        </p>
        <p>
            The key idea:
        </p>
        <ul class="bullet-tight">
            <li>
                Map each character <code>c</code> to an index <code>idx = c - 'a'</code>
                (or use a hash map / dictionary in higher-level languages).
            </li>
            <li>
                Follow child pointers for each character of the word. If a pointer is missing on insert,
                create a new node.
            </li>
            <li>
                For search, if a pointer is missing, the word is not present.
            </li>
        </ul>

        <div class="code-example" data-example="s13-ex1">
            <div class="code-example-header">
                <div class="code-example-title">
                    <span class="label">Example 1</span>
                    <span class="meta">Trie insert, search, and prefix check</span>
                </div>
            </div>

            <div class="tab-bar">
                <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
            </div>

            <!-- C -->
            <div class="code-panel" data-lang-panel="c">
                <pre><code class="language-c">// C - Trie implementation (lowercase 'a'..'z')
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define ALPHABET_SIZE 26

typedef struct TrieNode {
    struct TrieNode* children[ALPHABET_SIZE];
    bool is_end_of_word;
} TrieNode;

TrieNode* trie_node_create(void) {
    TrieNode* node = (TrieNode*)malloc(sizeof(TrieNode));
    if (!node) return NULL;
    for (int i = 0; i &lt; ALPHABET_SIZE; i++) {
        node-&gt;children[i] = NULL;
    }
    node-&gt;is_end_of_word = false;
    return node;
}

void trie_insert(TrieNode* root, const char* word) {
    TrieNode* cur = root;
    for (const char* p = word; *p; ++p) {
        char c = *p;
        if (c &lt; 'a' || c &gt; 'z') continue; // skip non-lowercase
        int idx = c - 'a';
        if (!cur-&gt;children[idx]) {
            cur-&gt;children[idx] = trie_node_create();
        }
        cur = cur-&gt;children[idx];
    }
    cur-&gt;is_end_of_word = true;
}

bool trie_search(TrieNode* root, const char* word) {
    TrieNode* cur = root;
    for (const char* p = word; *p; ++p) {
        char c = *p;
        if (c &lt; 'a' || c &gt; 'z') return false;
        int idx = c - 'a';
        if (!cur-&gt;children[idx]) {
            return false;
        }
        cur = cur-&gt;children[idx];
    }
    return cur-&gt;is_end_of_word;
}

bool trie_starts_with(TrieNode* root, const char* prefix) {
    TrieNode* cur = root;
    for (const char* p = prefix; *p; ++p) {
        char c = *p;
        if (c &lt; 'a' || c &gt; 'z') return false;
        int idx = c - 'a';
        if (!cur-&gt;children[idx]) {
            return false;
        }
        cur = cur-&gt;children[idx];
    }
    return true;
}</code></pre>
            </div>

            <!-- C++ -->
            <div class="code-panel" data-lang-panel="cpp">
                <pre><code class="language-cpp">// C++ - Trie implementation
#include &lt;array&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

struct TrieNode {
    std::array&lt;std::unique_ptr&lt;TrieNode&gt;, 26&gt; children{};
    bool isEnd = false;
};

class Trie {
public:
    Trie() : root(std::make_unique&lt;TrieNode&gt;()) {}

    void insert(const std::string&amp; word) {
        TrieNode* cur = root.get();
        for (char ch : word) {
            if (ch &lt; 'a' || ch &gt; 'z') continue;
            int idx = ch - 'a';
            if (!cur-&gt;children[idx]) {
                cur-&gt;children[idx] = std::make_unique&lt;TrieNode&gt;();
            }
            cur = cur-&gt;children[idx].get();
        }
        cur-&gt;isEnd = true;
    }

    bool search(const std::string&amp; word) const {
        const TrieNode* cur = root.get();
        for (char ch : word) {
            if (ch &lt; 'a' || ch &gt; 'z') return false;
            int idx = ch - 'a';
            if (!cur-&gt;children[idx]) {
                return false;
            }
            cur = cur-&gt;children[idx].get();
        }
        return cur-&gt;isEnd;
    }

    bool startsWith(const std::string&amp; prefix) const {
        const TrieNode* cur = root.get();
        for (char ch : prefix) {
            if (ch &lt; 'a' || ch &gt; 'z') return false;
            int idx = ch - 'a';
            if (!cur-&gt;children[idx]) {
                return false;
            }
            cur = cur-&gt;children[idx].get();
        }
        return true;
    }

private:
    std::unique_ptr&lt;TrieNode&gt; root;
};</code></pre>
            </div>

            <!-- Java -->
            <div class="code-panel" data-lang-panel="java">
                <pre><code class="language-java">// Java - Trie implementation
class TrieNode {
    TrieNode[] children = new TrieNode[26];
    boolean isEndOfWord = false;
}

class Trie {
    private final TrieNode root = new TrieNode();

    public void insert(String word) {
        TrieNode cur = root;
        for (char ch : word.toLowerCase().toCharArray()) {
            if (ch &lt; 'a' || ch &gt; 'z') continue;
            int idx = ch - 'a';
            if (cur.children[idx] == null) {
                cur.children[idx] = new TrieNode();
            }
            cur = cur.children[idx];
        }
        cur.isEndOfWord = true;
    }

    public boolean search(String word) {
        TrieNode cur = root;
        for (char ch : word.toLowerCase().toCharArray()) {
            if (ch &lt; 'a' || ch &gt; 'z') return false;
            int idx = ch - 'a';
            if (cur.children[idx] == null) {
                return false;
            }
            cur = cur.children[idx];
        }
        return cur.isEndOfWord;
    }

    public boolean startsWith(String prefix) {
        TrieNode cur = root;
        for (char ch : prefix.toLowerCase().toCharArray()) {
            if (ch &lt; 'a' || ch &gt; 'z') return false;
            int idx = ch - 'a';
            if (cur.children[idx] == null) {
                return false;
            }
            cur = cur.children[idx];
        }
        return true;
    }
}</code></pre>
            </div>

            <!-- JavaScript -->
            <div class="code-panel" data-lang-panel="js">
                <pre><code class="language-javascript">// JavaScript - Trie implementation (using plain objects)
class TrieNode {
    constructor() {
        this.children = {};      // key: character, value: TrieNode
        this.isEndOfWord = false;
    }
}

class Trie {
    constructor() {
        this.root = new TrieNode();
    }

    insert(word) {
        let cur = this.root;
        for (const ch of word.toLowerCase()) {
            if (ch &lt; 'a' || ch &gt; 'z') continue;
            if (!cur.children[ch]) {
                cur.children[ch] = new TrieNode();
            }
            cur = cur.children[ch];
        }
        cur.isEndOfWord = true;
    }

    search(word) {
        let cur = this.root;
        for (const ch of word.toLowerCase()) {
            if (ch &lt; 'a' || ch &gt; 'z') return false;
            if (!cur.children[ch]) {
                return false;
            }
            cur = cur.children[ch];
        }
        return cur.isEndOfWord;
    }

    startsWith(prefix) {
        let cur = this.root;
        for (const ch of prefix.toLowerCase()) {
            if (ch &lt; 'a' || ch &gt; 'z') return false;
            if (!cur.children[ch]) {
                return false;
            }
            cur = cur.children[ch];
        }
        return true;
    }
}</code></pre>
            </div>

            <!-- C# -->
            <div class="code-panel" data-lang-panel="cs">
                <pre><code class="language-csharp">// C# - Trie implementation
public class TrieNode {
    public TrieNode[] Children = new TrieNode[26];
    public bool IsEndOfWord = false;
}

public class Trie {
    private readonly TrieNode _root = new TrieNode();

    public void Insert(string word) {
        var cur = _root;
        foreach (char chRaw in word.ToLower()) {
            char ch = chRaw;
            if (ch &lt; 'a' || ch &gt; 'z') continue;
            int idx = ch - 'a';
            if (cur.Children[idx] == null) {
                cur.Children[idx] = new TrieNode();
            }
            cur = cur.Children[idx];
        }
        cur.IsEndOfWord = true;
    }

    public bool Search(string word) {
        var cur = _root;
        foreach (char chRaw in word.ToLower()) {
            char ch = chRaw;
            if (ch &lt; 'a' || ch &gt; 'z') return false;
            int idx = ch - 'a';
            if (cur.Children[idx] == null) {
                return false;
            }
            cur = cur.Children[idx];
        }
        return cur.IsEndOfWord;
    }

    public bool StartsWith(string prefix) {
        var cur = _root;
        foreach (char chRaw in prefix.ToLower()) {
            char ch = chRaw;
            if (ch &lt; 'a' || ch &gt; 'z') return false;
            int idx = ch - 'a';
            if (cur.Children[idx] == null) {
                return false;
            }
            cur = cur.Children[idx];
        }
        return true;
    }
}</code></pre>
            </div>

            <!-- Python -->
            <div class="code-panel" data-lang-panel="py">
                <pre><code class="language-python"># Python - Trie implementation
from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict

@dataclass
class TrieNode:
    children: Dict[str, "TrieNode"] = field(default_factory=dict)
    is_end_of_word: bool = False

class Trie:
    def __init__(self) -&gt; None:
        self.root = TrieNode()

    def insert(self, word: str) -&gt; None:
        cur = self.root
        for ch in word.lower():
            if ch &lt; "a" or ch &gt; "z":
                continue
            if ch not in cur.children:
                cur.children[ch] = TrieNode()
            cur = cur.children[ch]
        cur.is_end_of_word = True

    def search(self, word: str) -&gt; bool:
        cur = self.root
        for ch in word.lower():
            if ch &lt; "a" or ch &gt; "z":
                return False
            if ch not in cur.children:
                return False
            cur = cur.children[ch]
        return cur.is_end_of_word

    def starts_with(self, prefix: str) -&gt; bool:
        cur = self.root
        for ch in prefix.lower():
            if ch &lt; "a" or ch &gt; "z":
                return False
            if ch not in cur.children:
                return False
            cur = cur.children[ch]
        return True</code></pre>
            </div>

            <div class="complexity-note">
                Time per operation (<code>insert</code>, <code>search</code>, <code>startsWith</code>):
                <strong>O(L)</strong>, where <code>L</code> is the length of the word/prefix. &nbsp;|&nbsp;
                Extra space: proportional to total characters stored across all words.
            </div>
        </div>

        <hr>

        <!-- ======================= Example 2 - Prefix-based search ======================= -->
        <h3>
            13.4 Example 2 - Autocomplete-Style Prefix Search
            <button type="button" class="deep-dive-trigger inline" data-deep-id="deep-dive-s13-ex2">
                Dig deeper
            </button>
            <button type="button" class="understand-trigger inline" data-understand-id="understand-s13-ex2">
                Understand the algorithm
            </button>
        </h3>
        <p>
            Many trie problems ask you to return <em>all words</em> with a given prefix, or to count how many
            words share a prefix. The pattern is always:
        </p>
        <ol>
            <li>Walk down the trie according to the prefix.</li>
            <li>If you get stuck (missing child), there are zero matches.</li>
            <li>Otherwise, collect all words in the subtree rooted at that node.</li>
        </ol>

        <div class="code-example" data-example="s13-ex2">
            <div class="code-example-header">
                <div class="code-example-title">
                    <span class="label">Example 2</span>
                    <span class="meta">Collect all words with a given prefix (Python &amp; JavaScript)</span>
                </div>
            </div>

            <div class="tab-bar">
                <button class="tab-button active" data-lang="py"><span class="dot"></span>Python</button>
                <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
            </div>

            <!-- Python -->
            <div class="code-panel" data-lang-panel="py">
                <pre><code class="language-python"># Python - autocomplete-style prefix search
from typing import List

class TrieWithWords(Trie):
    def _collect(self, node: TrieNode, prefix: str, out: List[str]) -&gt; None:
        if node.is_end_of_word:
            out.append(prefix)
        for ch, child in node.children.items():
            self._collect(child, prefix + ch, out)

    def words_with_prefix(self, prefix: str) -&gt; List[str]:
        cur = self.root
        for ch in prefix.lower():
            if ch &lt; "a" or ch &gt; "z":
                return []
            if ch not in cur.children:
                return []
            cur = cur.children[ch]
        result: List[str] = []
        self._collect(cur, prefix.lower(), result)
        return result

# Example usage:
# trie = TrieWithWords()
# for w in ["apple", "app", "apply", "apt", "bat"]:
#     trie.insert(w)
# print(trie.words_with_prefix("app"))  # ["app", "apple", "apply"] (order may vary)</code></pre>
            </div>

            <!-- JavaScript -->
            <div class="code-panel" data-lang-panel="js">
                <pre><code class="language-javascript">// JavaScript - autocomplete-style prefix search
class TrieWithWords extends Trie {
    _collect(node, prefix, out) {
        if (node.isEndOfWord) {
            out.push(prefix);
        }
        for (const [ch, child] of Object.entries(node.children)) {
            this._collect(child, prefix + ch, out);
        }
    }

    wordsWithPrefix(prefix) {
        let cur = this.root;
        for (const ch of prefix.toLowerCase()) {
            if (ch &lt; 'a' || ch &gt; 'z') {
                return [];
            }
            if (!cur.children[ch]) {
                return [];
            }
            cur = cur.children[ch];
        }
        const result = [];
        this._collect(cur, prefix.toLowerCase(), result);
        return result;
    }
}

// Example usage:
// const trie = new TrieWithWords();
// for (const w of ["apple", "app", "apply", "apt", "bat"]) {
//   trie.insert(w);
// }
// console.log(trie.wordsWithPrefix("app")); // ["app", "apple", "apply"] (order may vary)</code></pre>
            </div>

            <div class="complexity-note">
                Time: <strong>O(P + K)</strong>, where <code>P</code> is prefix length and <code>K</code> is
                total characters in returned words. &nbsp;|&nbsp;
                Extra space: <strong>O(K)</strong> for the output list.
            </div>
        </div>

        <hr>

        <!-- ======================= 13.5 When to Reach for a Trie ======================= -->
        <h2>13.5 When to Use a Trie vs Other Structures</h2>
        <ul>
            <li>
                You need fast <strong>prefix queries</strong> (e.g., autocomplete, word games):
                <strong>trie</strong> is usually the right tool.
            </li>
            <li>
                You only ever check <code>word in set</code> with no prefixes:
                often a <strong>hash set</strong> is simpler and fast enough.
            </li>
            <li>
                You need ordered results or range queries on strings:
                a <strong>sorted array</strong> plus binary search or a <strong>balanced BST</strong> also works.
            </li>
            <li>
                Memory is tight and your alphabet is large:
                tries can be memory-heavy; compressed tries or alternatives might be needed.
            </li>
        </ul>

        <div class="top-nav">
            <a href="problems-section13-tries.html">
                Problem Set for Section 13 Tries →
            </a>
        </div>
        <div class="next-section">
            <a href="section12-search-and-sort.html">
                ← Back to Section 12
            </a>
            &nbsp;&nbsp;
            <a href="section10-practice.html">
                Back to Practice Hub →
            </a>
        </div>

        <!-- ======================= Deep dive templates ======================= -->

        <div class="deep-dive-template" id="deep-dive-s13-what-is-trie"
            data-title="Why tries are called prefix trees" hidden>
            <p>
                A trie is sometimes called a <strong>prefix tree</strong> because each node represents a prefix
                of one or more stored strings. The root corresponds to the empty prefix, its children represent
                all prefixes of length 1, and so on.
            </p>
            <ul>
                <li>
                    If you follow edges labeled <code>c1, c2, ..., ck</code> from the root, you&apos;re looking at
                    the prefix <code>c1c2...ck</code>.
                </li>
                <li>
                    Any node that is marked as &ldquo;end of word&rdquo; corresponds to a full word stored in the trie.
                </li>
                <li>
                    Many different words can share the same initial path (e.g., <code>car</code>, <code>card</code>,
                    <code>care</code>).
                </li>
            </ul>
            <p>
                This sharing of prefixes is what gives tries an advantage when you have many words with common
                beginnings and need to query them by prefix.
            </p>
        </div>

        <div class="deep-dive-template" id="deep-dive-s13-core-ops"
            data-title="Complexity intuition for trie operations" hidden>
            <p>
                Every core trie operation walks at most one node per character. That&apos;s why time is measured
                in terms of <code>L</code>, the word length, instead of the number of words <code>N</code>:
            </p>
            <ul>
                <li>
                    <strong>Insert:</strong> you go down the tree creating missing nodes; the cost is proportional
                    to the number of characters you actually traverse.
                </li>
                <li>
                    <strong>Search:</strong> you look up each edge; if one is missing, you stop early.
                </li>
                <li>
                    <strong>Prefix check:</strong> the same as search, but you don&apos;t require the final node
                    to be marked as a full word.
                </li>
            </ul>
            <p>
                In contrast, searching an unsorted list is <strong>O(N)</strong> and even a hash table still expects
                you to scan the entire key; tries give you a direct path for each character.
            </p>
        </div>

        <div class="deep-dive-template" id="deep-dive-s13-ex1"
            data-title="Design choices in a trie implementation" hidden>
            <p>
                There are a few common design choices when building a trie:
            </p>
            <ul>
                <li>
                    <strong>Child storage:</strong>
                    fixed-size array (fast but uses more memory) vs map/dictionary (less memory, slightly slower).
                </li>
                <li>
                    <strong>End-of-word marking:</strong>
                    you can use a boolean flag <code>isEnd</code> or an integer <code>word_count</code> if you want
                    to support duplicates or track counts.
                </li>
                <li>
                    <strong>Alphabet assumptions:</strong>
                    this example uses <code>'a'..'z'</code>. In production you might need Unicode or larger alphabets.
                </li>
            </ul>
            <p>
                In interviews, the simple &ldquo;array of size 26&rdquo; approach is usually fine and keeps the
                implementation short while still demonstrating the core idea.
            </p>
        </div>

        <div class="deep-dive-template" id="deep-dive-s13-ex2"
            data-title="DFS over a trie subtree for autocomplete" hidden>
            <p>
                Once you&apos;ve navigated to the node corresponding to a prefix, you can perform a simple DFS or BFS
                over that node&apos;s subtree to generate all completions:
            </p>
            <ul>
                <li>
                    You maintain the current prefix string and append characters as you go deeper.
                </li>
                <li>
                    Every time you hit a node marked as end-of-word, you add the current prefix to your results.
                </li>
                <li>
                    This traversal naturally enumerates all matching words with that prefix.
                </li>
            </ul>
            <p>
                The total work for enumeration is proportional to the size of the output
                (the total characters in all matching words), which is as efficient as possible.
            </p>
        </div>

        <!-- ======================= Understand the algorithm templates ======================= -->

        <div class="understand-template" id="understand-s13-ex1"
            data-title="Step-by-step: inserting and searching in a trie" hidden>
            <p>
                Think about inserting the word <code>cat</code> into an empty trie:
            </p>
            <ol>
                <li>Start at the root node.</li>
                <li>
                    Look at <code>'c'</code>. The root has no child for <code>'c'</code> yet,
                    so create a new node and follow that edge.
                </li>
                <li>
                    Now at the <code>'c'</code> node, look at <code>'a'</code>. Again, create a child and move there.
                </li>
                <li>
                    At the <code>'a'</code> node, process <code>'t'</code>, create the child, and move there.
                </li>
                <li>
                    Mark the current node as an end-of-word node. That node represents the word <code>&quot;cat&quot;</code>.
                </li>
            </ol>
            <p>
                Searching for <code>&quot;cat&quot;</code> walks the same path: root → <code>'c'</code> → <code>'a'</code> → <code>'t'</code>.
                If any required child is missing, the search fails immediately. If you reach the final node and it&apos;s
                marked as a word, the search succeeds.
            </p>
            <p>
                This is why the time is <strong>O(L)</strong>: we only ever do a constant amount of work per character.
            </p>
        </div>

        <div class="understand-template" id="understand-s13-ex2"
            data-title="Step-by-step: finding all words with a prefix" hidden>
            <p>
                For a prefix like <code>&quot;app&quot;</code> in a dictionary containing
                <code>app, apple, apply, apt, bat</code>:
            </p>
            <ol>
                <li>
                    Walk the trie along <code>'a'</code> → <code>'p'</code> → <code>'p'</code>.
                    If at any step the child is missing, there are no matches.
                </li>
                <li>
                    Once you reach the node after the second <code>'p'</code>, you are at the &ldquo;prefix node&rdquo;.
                </li>
                <li>
                    Run a DFS starting from that node:
                    <ul>
                        <li>If a node is end-of-word, record the prefix string built so far.</li>
                        <li>For each child character <code>ch</code>, append <code>ch</code> to the prefix and recurse.</li>
                    </ul>
                </li>
                <li>
                    You eventually discover <code>app</code>, <code>apple</code>, and <code>apply</code> as complete words.
                </li>
            </ol>
            <p>
                Notice that words like <code>bat</code> are never visited at all, because they&apos;re outside the prefix subtree.
                This is exactly why tries are so useful for prefix-constrained queries.
            </p>
        </div>

        <!-- ======================= Modal shells ======================= -->

        <!-- Deep dive modal shell -->
        <div class="deep-dive-backdrop" id="deep-dive-backdrop" aria-hidden="true">
            <div class="deep-dive-modal" role="dialog" aria-modal="true" aria-labelledby="deep-dive-title">
                <button type="button" class="deep-dive-close" aria-label="Close">&times;</button>
                <h2 id="deep-dive-title">&nbsp;</h2>
                <div class="deep-dive-body"></div>
            </div>
        </div>

        <!-- Understand-the-algorithm modal shell -->
        <div class="understand-backdrop" id="understand-backdrop" aria-hidden="true">
            <div class="understand-modal" role="dialog" aria-modal="true" aria-labelledby="understand-title">
                <button type="button" class="understand-close" aria-label="Close">&times;</button>
                <h2 id="understand-title">&nbsp;</h2>
                <div class="understand-body"></div>
            </div>
        </div>

    </main>
</body>

</html>
