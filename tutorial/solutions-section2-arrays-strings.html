<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Solutions - Section 2 Arrays &amp; Strings</title>

    <!-- Site styles -->
    <link rel="stylesheet" href="css/site.css">

    <!-- Highlight.js theme (initial, can be changed via selector) -->
    <link id="hljs-theme" rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

    <!-- highlight.js core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- highlight.js languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

    <!-- Site scripts (tabs, highlight init, prefs, cookies, etc.) -->
    <script src="js/site.js"></script>

    <!-- Favicon -->
    <link rel="icon" href="img/icon.svg" type="image/svg+xml" sizes="any">
</head>

<body>
    <main>
        <div class="top-nav">
            <a href="section10-practice.html">← Back to Practice Hub</a>
            &nbsp;&nbsp;
            <a href="problems-section2-arrays-strings.html">← Back to Section 2 Problems</a>
            &nbsp;&nbsp;
            <a href="section2-arrays-strings.html">View Section 2 Lesson →</a>
        </div>

        <div class="kicker">Section 2 - Solutions</div>
        <h1>Arrays &amp; Strings - Detailed Solutions</h1>
        <p class="tagline">
            These solutions walk through core patterns for arrays and strings: in-place updates,
            two pointers, hash maps, and sliding windows. Each problem includes code in
            C, C++, Java, JavaScript, C#, and Python.
        </p>

        <div class="theme-picker">
            <label for="theme-select">Syntax theme:</label>
            <select id="theme-select">
                <option value="atom-one-dark">Dark</option>
                <option value="far">Blue</option>
                <option value="atom-one-light">Light</option>
            </select>
        </div>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 1 - Reverse an Array In-Place                     -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 1 - Reverse an Array In-Place</h2>
            <p>
                We use two indices, one at the start and one at the end. Swap the elements,
                then move the pointers inward until they cross.
            </p>

            <div class="code-example" data-example="s2p1">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 1</span>
                        <span class="meta">Two-pointer in-place reversal</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s2p1">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C
#include &lt;stddef.h&gt;

void reverse_array(int *arr, size_t n) {
    size_t i = 0;
    size_t j = (n == 0) ? 0 : n - 1;

    while (i &lt; j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
        i++;
        j--;
    }
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
#include &lt;vector&gt;
using namespace std;

void reverseArray(vector&lt;int&gt;&amp; arr) {
    int i = 0;
    int j = (int)arr.size() - 1;
    while (i &lt; j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
        i++;
        j--;
    }
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
void reverseArray(int[] arr) {
    int i = 0;
    int j = arr.length - 1;
    while (i &lt; j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
        i++;
        j--;
    }
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
function reverseArray(arr) {
    let i = 0;
    let j = arr.length - 1;
    while (i &lt; j) {
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
        i++;
        j--;
    }
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
void ReverseArray(int[] arr) {
    int i = 0;
    int j = arr.Length - 1;
    while (i &lt; j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
        i++;
        j--;
    }
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
from typing import List

def reverse_array(arr: List[int]) -&gt; None:
    i = 0
    j = len(arr) - 1
    while i &lt; j:
        arr[i], arr[j] = arr[j], arr[i]
        i += 1
        j -= 1</code></pre>
                </div>

                <div class="complexity-note">
                    Time: we do about <code>n / 2</code> swaps → <strong>O(n)</strong>. &nbsp;|&nbsp;
                    Extra space: only a few variables → <strong>O(1)</strong>.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 2 - Two-Sum                                      -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 2 - Two-Sum (Brute Force vs. Hash Map)</h2>
            <p>
                We show both the brute-force solution (check all pairs) and a faster hash-based solution.
            </p>

            <div class="code-example" data-example="s2p2">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 2</span>
                        <span class="meta">Compare O(n²) vs. O(n) with hashing</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s2p2">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C
#include &lt;stdbool.h&gt;

// Brute force O(n^2)
bool two_sum_bruteforce(const int *nums, int n, int target) {
    for (int i = 0; i &lt; n; i++) {
        for (int j = i + 1; j &lt; n; j++) {
            if (nums[i] + nums[j] == target) {
                return true;
            }
        }
    }
    return false;
}

// Hash-based solution would require a hash table implementation.
// In interviews, you can describe using an unordered_set-like API:
// scan once, check if (target - x) is in the set, then insert x.</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
#include &lt;vector&gt;
#include &lt;unordered_set&gt;
using namespace std;

// Brute force O(n^2)
bool twoSumBruteforce(const vector&lt;int&gt;&amp; nums, int target) {
    int n = (int)nums.size();
    for (int i = 0; i &lt; n; i++) {
        for (int j = i + 1; j &lt; n; j++) {
            if (nums[i] + nums[j] == target) return true;
        }
    }
    return false;
}

// Hash-based O(n) expected
bool twoSumHash(const vector&lt;int&gt;&amp; nums, int target) {
    unordered_set&lt;int&gt; seen;
    for (int x : nums) {
        int need = target - x;
        if (seen.count(need)) return true;
        seen.insert(x);
    }
    return false;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
import java.util.HashSet;
import java.util.Set;

// Brute force O(n^2)
boolean twoSumBruteforce(int[] nums, int target) {
    int n = nums.length;
    for (int i = 0; i &lt; n; i++) {
        for (int j = i + 1; j &lt; n; j++) {
            if (nums[i] + nums[j] == target) {
                return true;
            }
        }
    }
    return false;
}

// Hash-based O(n) expected
boolean twoSumHash(int[] nums, int target) {
    Set&lt;Integer&gt; seen = new HashSet&lt;&gt;();
    for (int x : nums) {
        int need = target - x;
        if (seen.contains(need)) {
            return true;
        }
        seen.add(x);
    }
    return false;
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript

// Brute force O(n^2)
function twoSumBruteforce(nums, target) {
    const n = nums.length;
    for (let i = 0; i &lt; n; i++) {
        for (let j = i + 1; j &lt; n; j++) {
            if (nums[i] + nums[j] === target) {
                return true;
            }
        }
    }
    return false;
}

// Hash-based O(n) expected
function twoSumHash(nums, target) {
    const seen = new Set();
    for (const x of nums) {
        const need = target - x;
        if (seen.has(need)) {
            return true;
        }
        seen.add(x);
    }
    return false;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
using System.Collections.Generic;

// Brute force O(n^2)
bool TwoSumBruteforce(int[] nums, int target) {
    int n = nums.Length;
    for (int i = 0; i &lt; n; i++) {
        for (int j = i + 1; j &lt; n; j++) {
            if (nums[i] + nums[j] == target) {
                return true;
            }
        }
    }
    return false;
}

// Hash-based O(n) expected
bool TwoSumHash(int[] nums, int target) {
    var seen = new HashSet&lt;int&gt;();
    foreach (int x in nums) {
        int need = target - x;
        if (seen.Contains(need)) {
            return true;
        }
        seen.Add(x);
    }
    return false;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
from typing import List

def two_sum_bruteforce(nums: List[int], target: int) -&gt; bool:
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return True
    return False

def two_sum_hash(nums: List[int], target: int) -&gt; bool:
    seen: set[int] = set()
    for x in nums:
        need = target - x
        if need in seen:
            return True
        seen.add(x)
    return False</code></pre>
                </div>

                <div class="complexity-note">
                    Brute force: examine all pairs → <strong>O(n²)</strong> time, <strong>O(1)</strong> space. &nbsp;|&nbsp;
                    Hash-based: scan once with a set → expected <strong>O(n)</strong> time, <strong>O(n)</strong> extra space.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 3 - Move Zeros to the End                         -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 3 - Move Zeros to the End</h2>
            <p>
                Use a write pointer to compact non-zero elements to the front in order. Then fill the remainder
                with zeros.
            </p>

            <div class="code-example" data-example="s2p3">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 3</span>
                        <span class="meta">Stable compaction of non-zeros</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s2p3">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C
#include &lt;stddef.h&gt;

void move_zeroes(int *nums, size_t n) {
    size_t write = 0;

    for (size_t read = 0; read &lt; n; read++) {
        if (nums[read] != 0) {
            nums[write] = nums[read];
            write++;
        }
    }
    while (write &lt; n) {
        nums[write] = 0;
        write++;
    }
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
#include &lt;vector&gt;
using namespace std;

void moveZeroes(vector&lt;int&gt;&amp; nums) {
    int write = 0;
    for (int read = 0; read &lt; (int)nums.size(); read++) {
        if (nums[read] != 0) {
            nums[write] = nums[read];
            write++;
        }
    }
    while (write &lt; (int)nums.size()) {
        nums[write] = 0;
        write++;
    }
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
void moveZeroes(int[] nums) {
    int write = 0;
    for (int read = 0; read &lt; nums.length; read++) {
        if (nums[read] != 0) {
            nums[write] = nums[read];
            write++;
        }
    }
    while (write &lt; nums.length) {
        nums[write] = 0;
        write++;
    }
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
function moveZeroes(nums) {
    let write = 0;
    for (let read = 0; read &lt; nums.length; read++) {
        if (nums[read] !== 0) {
            nums[write] = nums[read];
            write++;
        }
    }
    while (write &lt; nums.length) {
        nums[write] = 0;
        write++;
    }
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
void MoveZeroes(int[] nums) {
    int write = 0;
    for (int read = 0; read &lt; nums.Length; read++) {
        if (nums[read] != 0) {
            nums[write] = nums[read];
            write++;
        }
    }
    while (write &lt; nums.Length) {
        nums[write] = 0;
        write++;
    }
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
from typing import List

def move_zeroes(nums: List[int]) -&gt; None:
    write = 0
    for read in range(len(nums)):
        if nums[read] != 0:
            nums[write] = nums[read]
            write += 1
    while write &lt; len(nums):
        nums[write] = 0
        write += 1</code></pre>
                </div>

                <div class="complexity-note">
                    Time: two passes over the array → <strong>O(n)</strong>. &nbsp;|&nbsp;
                    Extra space: just a couple of indices → <strong>O(1)</strong>.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 4 - Check for Anagram                             -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 4 - Check for Anagram</h2>
            <p>
                Because we are restricted to lowercase letters a-z, we can use a fixed-size array of length 26
                for frequencies rather than a full hash map.
            </p>

            <div class="code-example" data-example="s2p4">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 4</span>
                        <span class="meta">Frequency counting with fixed alphabet</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s2p4">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C
#include &lt;stdbool.h&gt;
#include &lt;string.h&gt;

bool is_anagram(const char *s, const char *t) {
    if (strlen(s) != strlen(t)) return false;

    int freq[26] = {0};
    for (size_t i = 0; s[i] != '\0'; i++) {
        freq[s[i] - 'a']++;
        freq[t[i] - 'a']--;
    }
    for (int i = 0; i &lt; 26; i++) {
        if (freq[i] != 0) return false;
    }
    return true;
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
#include &lt;string&gt;
using namespace std;

bool isAnagram(const string&amp; s, const string&amp; t) {
    if (s.size() != t.size()) return false;
    int freq[26] = {0};
    for (size_t i = 0; i &lt; s.size(); i++) {
        freq[s[i] - 'a']++;
        freq[t[i] - 'a']--;
    }
    for (int i = 0; i &lt; 26; i++) {
        if (freq[i] != 0) return false;
    }
    return true;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) return false;
    int[] freq = new int[26];
    for (int i = 0; i &lt; s.length(); i++) {
        freq[s.charAt(i) - 'a']++;
        freq[t.charAt(i) - 'a']--;
    }
    for (int f : freq) {
        if (f != 0) return false;
    }
    return true;
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
function isAnagram(s, t) {
    if (s.length !== t.length) return false;
    const freq = new Array(26).fill(0);
    for (let i = 0; i &lt; s.length; i++) {
        freq[s.charCodeAt(i) - 97]++;
        freq[t.charCodeAt(i) - 97]--;
    }
    for (let i = 0; i &lt; 26; i++) {
        if (freq[i] !== 0) return false;
    }
    return true;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
bool IsAnagram(string s, string t) {
    if (s.Length != t.Length) return false;
    var freq = new int[26];
    for (int i = 0; i &lt; s.Length; i++) {
        freq[s[i] - 'a']++;
        freq[t[i] - 'a']--;
    }
    for (int i = 0; i &lt; 26; i++) {
        if (freq[i] != 0) return false;
    }
    return true;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
def is_anagram(s: str, t: str) -&gt; bool:
    if len(s) != len(t):
        return False
    freq = [0] * 26
    for ch_s, ch_t in zip(s, t):
        freq[ord(ch_s) - ord('a')] += 1
        freq[ord(ch_t) - ord('a')] -= 1
    return all(f == 0 for f in freq)</code></pre>
                </div>

                <div class="complexity-note">
                    Time: one pass over the strings plus a fixed 26-check → <strong>O(n)</strong>. &nbsp;|&nbsp;
                    Extra space: 26-size array → <strong>O(1)</strong>.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 5 - Longest Substring Without Repeating Characters-->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 5 - Longest Substring Without Repeating Characters</h2>
            <p>
                We maintain a sliding window [left, right] with no duplicate characters using a map from character
                to its most recent index. When a duplicate is found inside the window, we move left to one past
                the previous occurrence.
            </p>

            <div class="code-example" data-example="s2p5">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 5</span>
                        <span class="meta">Sliding window with last-seen indices</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s2p5">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C
#include &lt;string.h&gt;

// Assume ASCII (0-127). Initialize last_pos to -1.
int length_of_longest_substring(const char *s) {
    int last_pos[128];
    for (int i = 0; i &lt; 128; i++) last_pos[i] = -1;

    int best = 0;
    int left = 0;
    for (int right = 0; s[right] != '\0'; right++) {
        unsigned char ch = (unsigned char)s[right];
        if (last_pos[ch] &gt;= left) {
            left = last_pos[ch] + 1;
        }
        last_pos[ch] = right;
        int window_len = right - left + 1;
        if (window_len &gt; best) best = window_len;
    }
    return best;
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

int lengthOfLongestSubstring(const string&amp; s) {
    vector&lt;int&gt; last_pos(128, -1);
    int best = 0;
    int left = 0;
    for (int right = 0; right &lt; (int)s.size(); right++) {
        unsigned char ch = (unsigned char)s[right];
        if (last_pos[ch] &gt;= left) {
            left = last_pos[ch] + 1;
        }
        last_pos[ch] = right;
        int window_len = right - left + 1;
        if (window_len &gt; best) best = window_len;
    }
    return best;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
int lengthOfLongestSubstring(String s) {
    int[] lastPos = new int[128];
    for (int i = 0; i &lt; 128; i++) lastPos[i] = -1;

    int best = 0;
    int left = 0;
    for (int right = 0; right &lt; s.length(); right++) {
        char ch = s.charAt(right);
        if (lastPos[ch] &gt;= left) {
            left = lastPos[ch] + 1;
        }
        lastPos[ch] = right;
        int windowLen = right - left + 1;
        if (windowLen &gt; best) best = windowLen;
    }
    return best;
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
function lengthOfLongestSubstring(s) {
    const lastPos = new Map();
    let best = 0;
    let left = 0;

    for (let right = 0; right &lt; s.length; right++) {
        const ch = s[right];
        if (lastPos.has(ch) &amp;&amp; lastPos.get(ch) &gt;= left) {
            left = lastPos.get(ch) + 1;
        }
        lastPos.set(ch, right);
        const windowLen = right - left + 1;
        if (windowLen &gt; best) best = windowLen;
    }
    return best;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
using System.Collections.Generic;

int LengthOfLongestSubstring(string s) {
    var lastPos = new Dictionary&lt;char, int&gt;();
    int best = 0;
    int left = 0;

    for (int right = 0; right &lt; s.Length; right++) {
        char ch = s[right];
        if (lastPos.TryGetValue(ch, out int prev) &amp;&amp; prev &gt;= left) {
            left = prev + 1;
        }
        lastPos[ch] = right;
        int windowLen = right - left + 1;
        if (windowLen &gt; best) best = windowLen;
    }
    return best;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
def length_of_longest_substring(s: str) -&gt; int:
    last_pos: dict[str, int] = {}
    left = 0
    best = 0
    for right, ch in enumerate(s):
        if ch in last_pos and last_pos[ch] &gt;= left:
            left = last_pos[ch] + 1
        last_pos[ch] = right
        window_len = right - left + 1
        if window_len &gt; best:
            best = window_len
    return best</code></pre>
                </div>

                <div class="complexity-note">
                    Each index moves forward at most once → time <strong>O(n)</strong>. &nbsp;|&nbsp;
                    Extra space: up to one map entry per distinct character → <strong>O(min(n, alphabet))</strong>.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 6 - Rotate Array (Right by k)                     -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 6 - Rotate Array (Right by k)</h2>
            <p>
                Use the triple-reversal trick: reverse the entire array, then reverse the first
                <code>k</code> elements, then reverse the remaining <code>n - k</code> elements.
                Normalize <code>k</code> with <code>k % n</code>.
            </p>

            <div class="code-example" data-example="s2p6">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 6</span>
                        <span class="meta">Three-reverse rotation trick</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s2p6">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C
#include &lt;stddef.h&gt;

static void reverse_range(int *nums, size_t l, size_t r) {
    while (l &lt; r) {
        int tmp = nums[l];
        nums[l] = nums[r];
        nums[r] = tmp;
        l++;
        r--;
    }
}

void rotate_array(int *nums, size_t n, size_t k) {
    if (n == 0) return;
    k %= n;
    if (k == 0) return;

    reverse_range(nums, 0, n - 1);
    reverse_range(nums, 0, k - 1);
    reverse_range(nums, k, n - 1);
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
#include &lt;vector&gt;
using namespace std;

static void reverseRange(vector&lt;int&gt;&amp; nums, int l, int r) {
    while (l &lt; r) {
        int tmp = nums[l];
        nums[l] = nums[r];
        nums[r] = tmp;
        l++;
        r--;
    }
}

void rotate(vector&lt;int&gt;&amp; nums, int k) {
    int n = (int)nums.size();
    if (n == 0) return;
    k %= n;
    if (k == 0) return;

    reverseRange(nums, 0, n - 1);
    reverseRange(nums, 0, k - 1);
    reverseRange(nums, k, n - 1);
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
void rotate(int[] nums, int k) {
    int n = nums.length;
    if (n == 0) return;
    k %= n;
    if (k == 0) return;

    reverseRange(nums, 0, n - 1);
    reverseRange(nums, 0, k - 1);
    reverseRange(nums, k, n - 1);
}

void reverseRange(int[] nums, int l, int r) {
    while (l &lt; r) {
        int tmp = nums[l];
        nums[l] = nums[r];
        nums[r] = tmp;
        l++;
        r--;
    }
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
function rotate(nums, k) {
    const n = nums.length;
    if (n === 0) return;
    k %= n;
    if (k === 0) return;

    reverseRange(nums, 0, n - 1);
    reverseRange(nums, 0, k - 1);
    reverseRange(nums, k, n - 1);
}

function reverseRange(nums, l, r) {
    while (l &lt; r) {
        const tmp = nums[l];
        nums[l] = nums[r];
        nums[r] = tmp;
        l++;
        r--;
    }
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
void Rotate(int[] nums, int k) {
    int n = nums.Length;
    if (n == 0) return;
    k %= n;
    if (k == 0) return;

    ReverseRange(nums, 0, n - 1);
    ReverseRange(nums, 0, k - 1);
    ReverseRange(nums, k, n - 1);
}

void ReverseRange(int[] nums, int l, int r) {
    while (l &lt; r) {
        int tmp = nums[l];
        nums[l] = nums[r];
        nums[r] = tmp;
        l++;
        r--;
    }
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
from typing import List

def rotate(nums: List[int], k: int) -&gt; None:
    n = len(nums)
    if n == 0:
        return
    k %= n
    if k == 0:
        return

    reverse_range(nums, 0, n - 1)
    reverse_range(nums, 0, k - 1)
    reverse_range(nums, k, n - 1)

def reverse_range(nums: List[int], l: int, r: int) -&gt; None:
    while l &lt; r:
        nums[l], nums[r] = nums[r], nums[l]
        l += 1
        r -= 1</code></pre>
                </div>

                <div class="complexity-note">
                    Time: three passes over the array → <strong>O(n)</strong>. &nbsp;|&nbsp;
                    Extra space: in-place swaps only → <strong>O(1)</strong>.
                </div>
            </div>
        </section>

        <div class="next-section">
            <a href="problems-section2-arrays-strings.html">
                ← Back to Section 2 Problem Set
            </a>
            &nbsp;&nbsp;
            <a href="section10-practice.html">
                Back to Practice Hub →
            </a>
        </div>

        <!-- ======================= Understand-the-algorithm templates ======================= -->

        <div class="deep-dive-template" id="understand-s2p1"
            data-title="Step-by-step: Reverse an array in-place" hidden>
            <p>
                The core idea is to swap symmetric elements from the two ends of the array until the pointers meet
                in the middle.
            </p>
            <ol>
                <li>
                    <strong>Initialize two pointers:</strong>
                    <ul>
                        <li><code>i</code> starts at the beginning (index 0).</li>
                        <li><code>j</code> starts at the end (index <code>n - 1</code>).</li>
                    </ul>
                </li>
                <li>
                    <strong>Swap the outer elements:</strong>
                    <p>
                        While <code>i &lt; j</code>, we swap <code>arr[i]</code> with <code>arr[j]</code> using a
                        temporary variable (or tuple swap in Python).
                    </p>
                </li>
                <li>
                    <strong>Move pointers inward:</strong>
                    <ul>
                        <li>After each swap, increment <code>i</code> (move right).</li>
                        <li>Decrement <code>j</code> (move left).</li>
                    </ul>
                    <p>
                        This keeps pairing the next elements from the front with their matching elements from the back.
                    </p>
                </li>
                <li>
                    <strong>Stop condition:</strong>
                    <p>
                        As soon as <code>i</code> is no longer less than <code>j</code>, we have reversed the whole
                        array. Every element has been swapped into its mirror position exactly once.
                    </p>
                </li>
                <li>
                    <strong>Why it works:</strong>
                    <p>
                        Reversing is just mapping index <code>k</code> to <code>n - 1 - k</code>. Our two-pointer
                        loop performs these swaps in pairs, ensuring we never overwrite an element before it is used.
                        We only use constant extra space for a few variables.
                    </p>
                </li>
            </ol>
        </div>

        <div class="deep-dive-template" id="understand-s2p2"
            data-title="Step-by-step: Two-sum with brute force and hashing" hidden>
            <p>
                This solution compares two strategies for checking whether any pair sums to a target:
                a simple double loop and a faster hash-based approach.
            </p>
            <h3>1. Brute-force O(n²)</h3>
            <ol>
                <li>
                    <strong>Check all pairs:</strong>
                    <p>
                        Use two indices <code>i</code> and <code>j</code> where <code>j &gt; i</code>. For every
                        <code>i</code>, we loop over all <code>j</code> that come after it.
                    </p>
                </li>
                <li>
                    <strong>Test the sum:</strong>
                    <p>
                        For each pair <code>(i, j)</code>, compute <code>nums[i] + nums[j]</code>.
                        If the result equals <code>target</code>, we can immediately return <code>true</code>.
                    </p>
                </li>
                <li>
                    <strong>No pair found:</strong>
                    <p>
                        If we finish both loops without a match, return <code>false</code>. We have tried all
                        <code>O(n²)</code> combinations.
                    </p>
                </li>
            </ol>
            <h3>2. Hash-based O(n) expected</h3>
            <ol>
                <li>
                    <strong>Maintain a set of seen numbers:</strong>
                    <p>
                        Initialize an empty set (or hash set). We iterate through the array once from left to right.
                    </p>
                </li>
                <li>
                    <strong>For each element x:</strong>
                    <ul>
                        <li>Compute <code>need = target - x</code>.</li>
                        <li>
                            If <code>need</code> is already in the set, then we have found
                            <code>need + x = target</code>, so return <code>true</code>.
                        </li>
                        <li>
                            Otherwise, insert <code>x</code> into the set and continue.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Why the set works:</strong>
                    <p>
                        The set is effectively remembering all values we have seen so far. When we see
                        <code>x</code>, we check if its partner <code>target - x</code> has shown up earlier.
                        Hash set operations are expected O(1), so the whole scan is O(n) on average.
                    </p>
                </li>
                <li>
                    <strong>End of array:</strong>
                    <p>
                        If we finish the loop without finding a match, no such pair exists and we return
                        <code>false</code>.
                    </p>
                </li>
            </ol>
            <p>
                In interviews, it is useful to start with the brute-force idea, then improve it by explaining how
                hashing cuts the search from &quot;all pairs&quot; to a single linear scan.
            </p>
        </div>

        <div class="deep-dive-template" id="understand-s2p3"
            data-title="Step-by-step: Move zeroes to the end while keeping order" hidden>
            <p>
                The goal is to move all zeros to the end but keep non-zero elements in their original order.
                We do this in two phases using a <em>write pointer</em>.
            </p>
            <ol>
                <li>
                    <strong>Initialize write index:</strong>
                    <p>
                        Set <code>write = 0</code>. This marks the position where the next non-zero should be placed.
                    </p>
                </li>
                <li>
                    <strong>First pass - compact non-zeros:</strong>
                    <ul>
                        <li>Loop <code>read</code> from <code>0</code> to <code>n - 1</code>.</li>
                        <li>
                            If <code>nums[read] != 0</code>, copy it to <code>nums[write]</code>
                            and increment <code>write</code>.
                        </li>
                        <li>
                            If the element is zero, we simply skip it; <code>write</code> does not move,
                            so zeros get &quot;squeezed out&quot; of the front part.
                        </li>
                    </ul>
                    <p>
                        After this pass, indices <code>[0 .. write-1]</code> hold all non-zero values in order.
                        Indices <code>[write .. n-1]</code> are either leftover values or zeros that we still need to overwrite.
                    </p>
                </li>
                <li>
                    <strong>Second pass - fill remaining with zeros:</strong>
                    <p>
                        While <code>write &lt; n</code>, set <code>nums[write] = 0</code> and increment <code>write</code>.
                        This overwrites any garbage or old values with zeros.
                    </p>
                </li>
                <li>
                    <strong>Why order is preserved:</strong>
                    <p>
                        We always copy non-zero elements forward in the same order we encounter them, and never swap
                        them with later elements. That means the relative order of non-zero values never changes.
                    </p>
                </li>
                <li>
                    <strong>Space and time:</strong>
                    <p>
                        We only use two indices and touch each element a constant number of times, so the algorithm is
                        O(n) time and O(1) extra space.
                    </p>
                </li>
            </ol>
        </div>

        <div class="deep-dive-template" id="understand-s2p4"
            data-title="Step-by-step: Check if two strings are anagrams" hidden>
            <p>
                Two strings are anagrams if they use the same characters with the same frequencies, just in a
                different order. With only lowercase a-z, a fixed-size frequency array is enough.
            </p>
            <ol>
                <li>
                    <strong>Length check:</strong>
                    <p>
                        If <code>s</code> and <code>t</code> have different lengths, they cannot be anagrams,
                        so we immediately return <code>false</code>.
                    </p>
                </li>
                <li>
                    <strong>Initialize frequency array:</strong>
                    <p>
                        Create an array <code>freq[26]</code> and set all entries to 0. Each index corresponds to a
                        letter: index 0 for 'a', 1 for 'b', ..., 25 for 'z'.
                    </p>
                </li>
                <li>
                    <strong>Single pass over both strings:</strong>
                    <ul>
                        <li>For each position <code>i</code>:</li>
                        <li>Increment <code>freq[s[i] - 'a']</code> (we saw one more of that letter in <code>s</code>).</li>
                        <li>Decrement <code>freq[t[i] - 'a']</code> (we saw one more of that letter in <code>t</code>).</li>
                    </ul>
                    <p>
                        Doing this in lockstep means matching characters in <code>s</code> and <code>t</code>
                        cancel each other out.
                    </p>
                </li>
                <li>
                    <strong>Final frequency check:</strong>
                    <p>
                        After the loop, we scan through the 26 entries. If every entry is 0, then for every letter,
                        counts in <code>s</code> and <code>t</code> match exactly → they are anagrams.
                        If any entry is nonzero, the counts differ somewhere → not anagrams.
                    </p>
                </li>
                <li>
                    <strong>Why this is efficient:</strong>
                    <p>
                        The alphabet size is fixed (26), so the extra space is constant. We only loop over the strings
                        once, plus a small 26-element check, for O(n) time.
                    </p>
                </li>
            </ol>
        </div>

        <div class="deep-dive-template" id="understand-s2p5"
            data-title="Step-by-step: Longest substring without repeating characters" hidden>
            <p>
                We maintain a sliding window of characters that contains no duplicates, and expand/contract it as we
                scan the string.
            </p>
            <ol>
                <li>
                    <strong>Key data structures:</strong>
                    <ul>
                        <li><code>left</code>: start index of the current window.</li>
                        <li><code>right</code>: end index of the current window (loop variable).</li>
                        <li>
                            A map / array <code>last_pos</code> that stores the most recent index at which each
                            character appeared (or -1 if never seen).
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Expand window with right:</strong>
                    <p>
                        For each <code>right</code> from 0 to <code>n - 1</code>, we look at <code>ch = s[right]</code>
                        and ask: &quot;Have we seen this character inside the current window?&quot;
                    </p>
                </li>
                <li>
                    <strong>Detect duplicates inside the window:</strong>
                    <ul>
                        <li>
                            If <code>last_pos[ch] &gt;= left</code>, the last occurrence of <code>ch</code> lies within
                            the current window <code>[left, right]</code>.
                        </li>
                        <li>
                            To remove the duplicate, we move <code>left</code> to one position after that old index:
                            <code>left = last_pos[ch] + 1</code>.
                        </li>
                        <li>
                            This &quot;cuts off&quot; the part of the window that contained the previous <code>ch</code>.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Update last seen position:</strong>
                    <p>
                        Set <code>last_pos[ch] = right</code> to remember where we just saw this character.
                    </p>
                </li>
                <li>
                    <strong>Track the best window length:</strong>
                    <p>
                        The current window is always <code>[left, right]</code> with all unique characters.
                        Its length is <code>right - left + 1</code>. Update <code>best</code> if this window is longer
                        than anything seen so far.
                    </p>
                </li>
                <li>
                    <strong>Why it is linear time:</strong>
                    <p>
                        Each index moves forward at most once: <code>right</code> increases from 0 to <code>n - 1</code>,
                        and <code>left</code> only ever moves forward when duplicates are found. So the total work
                        is O(n), not O(n²).
                    </p>
                </li>
            </ol>
        </div>

        <div class="deep-dive-template" id="understand-s2p6"
            data-title="Step-by-step: Rotate array using three reversals" hidden>
            <p>
                Rotating right by <code>k</code> steps means the last <code>k</code> elements wrap around to the front.
                The triple-reversal trick achieves this in-place.
            </p>
            <ol>
                <li>
                    <strong>Normalize k:</strong>
                    <p>
                        If <code>n</code> is the array length, rotating by <code>k</code> and by
                        <code>k % n</code> are the same. So we compute <code>k %= n</code>. If <code>k == 0</code>,
                        nothing needs to be done.
                    </p>
                </li>
                <li>
                    <strong>Helper: reverse a subarray:</strong>
                    <p>
                        <code>reverse_range(nums, l, r)</code> swaps <code>nums[l]</code> with <code>nums[r]</code>,
                        then moves inward, just like the array-reversal algorithm.
                    </p>
                </li>
                <li>
                    <strong>Step 1 - reverse the whole array:</strong>
                    <p>
                        Call <code>reverse_range(nums, 0, n - 1)</code>.
                        This flips the entire array, so the previous end now comes to the front, but in reversed order.
                    </p>
                </li>
                <li>
                    <strong>Step 2 - reverse the first k elements:</strong>
                    <p>
                        Call <code>reverse_range(nums, 0, k - 1)</code>.
                        This re-reverses the first <code>k</code> elements so that they appear in the same order
                        as the original last <code>k</code> elements.
                    </p>
                </li>
                <li>
                    <strong>Step 3 - reverse the remaining n - k elements:</strong>
                    <p>
                        Call <code>reverse_range(nums, k, n - 1)</code>.
                        This fixes the order of the remaining part of the array so that it matches the original
                        first <code>n - k</code> elements.
                    </p>
                </li>
                <li>
                    <strong>Why the composition equals rotation:</strong>
                    <p>
                        Reversal is a simple, invertible operation. Doing &quot;reverse all&quot;, then &quot;reverse
                        prefix&quot;, then &quot;reverse suffix&quot; rearranges the elements exactly as a right
                        rotation by <code>k</code> would, but uses only constant extra space and O(n) time.
                    </p>
                </li>
            </ol>
        </div>

        <!-- ======================= Modal shell reused by all buttons ======================= -->

        <div class="deep-dive-backdrop" id="deep-dive-backdrop" aria-hidden="true">
            <div class="deep-dive-modal" role="dialog" aria-modal="true" aria-labelledby="deep-dive-title">
                <button type="button" class="deep-dive-close" aria-label="Close">&times;</button>
                <h2 id="deep-dive-title">&nbsp;</h2>
                <div class="deep-dive-body"></div>
            </div>
        </div>

    </main>
</body>

</html>
