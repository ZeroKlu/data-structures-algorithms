<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Solutions - Section 3 Linked Lists</title>

    <!-- Site styles -->
    <link rel="stylesheet" href="css/site.css">

    <!-- Highlight.js theme (initial, can be changed via selector) -->
    <link id="hljs-theme" rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

    <!-- highlight.js core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- highlight.js languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

    <!-- Site scripts (tabs, highlight init, prefs, cookies, etc.) -->
    <script src="js/site.js"></script>

    <!-- Favicon -->
    <link rel="icon" href="img/icon.svg" type="image/svg+xml" sizes="any">
</head>

<body>
    <main>
        <div class="top-nav">
            <a href="section10-practice.html">← Back to Practice Hub</a>
            &nbsp;&nbsp;
            <a href="problems-section3-linked-lists.html">← Back to Section 3 Problems</a>
            &nbsp;&nbsp;
            <a href="section3-linked-lists.html">View Section 3 Lesson →</a>
        </div>

        <div class="kicker">Section 3 - Solutions</div>
        <h1>Linked Lists - Detailed Solutions</h1>
        <p class="tagline">
            Multi-language implementations for core linked list patterns:
            basic pointer operations, reversal, cycle detection, middle-of-list,
            merging sorted lists, and removing the N-th node from the end.
        </p>

        <div class="theme-picker">
            <label for="theme-select">Syntax theme:</label>
            <select id="theme-select">
                <option value="atom-one-dark">Dark</option>
                <option value="far">Blue</option>
                <option value="atom-one-light">Light</option>
            </select>
        </div>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 1 - Basic Singly Linked List Operations           -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 1 - Basic Singly Linked List Operations</h2>
            <p>
                We assume the node definition:
            </p>
            <pre><code class="language-c">typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;</code></pre>

            <p>
                We want to implement three operations:
            </p>
            <ol>
                <li>Insert a new node with value <code>x</code> at the head.</li>
                <li>Insert a new node with value <code>x</code> after a given node <code>p</code>.</li>
                <li>Delete the node immediately after a given node <code>p</code> (if it exists).</li>
            </ol>
            <p>
                The key idea is that if we already have a pointer to the correct place, we only
                need to adjust a constant number of pointers, independent of the list length.
            </p>

            <div class="code-example" data-example="s3p1">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 1</span>
                        <span class="meta">Insert-head, insert-after, delete-after</span>
                    </div>
                    <button type="button" class="deep-dive-trigger" data-deep-id="understand-s3p1">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
                    <pre><code class="language-c">// C
#include &lt;stdlib.h&gt;

typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

// Insert at head: head pointer is updated via pointer-to-pointer
void insert_head(ListNode** head, int x) {
    ListNode* node = (ListNode*)malloc(sizeof(ListNode));
    node-&gt;val = x;
    node-&gt;next = *head;
    *head = node;
}

// Insert after node p (if p is non-NULL)
void insert_after(ListNode* p, int x) {
    if (!p) return;
    ListNode* node = (ListNode*)malloc(sizeof(ListNode));
    node-&gt;val = x;
    node-&gt;next = p-&gt;next;
    p-&gt;next = node;
}

// Delete node immediately after p (if it exists)
void delete_after(ListNode* p) {
    if (!p || !p-&gt;next) return;
    ListNode* doomed = p-&gt;next;
    p-&gt;next = doomed-&gt;next;
    free(doomed);
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
                    <pre><code class="language-cpp">// C++
#include &lt;cstdlib&gt;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int v) : val(v), next(nullptr) {}
};

// Insert at head: modify head by reference
void insertHead(ListNode*& head, int x) {
    ListNode* node = new ListNode(x);
    node-&gt;next = head;
    head = node;
}

// Insert after p
void insertAfter(ListNode* p, int x) {
    if (!p) return;
    ListNode* node = new ListNode(x);
    node-&gt;next = p-&gt;next;
    p-&gt;next = node;
}

// Delete after p
void deleteAfter(ListNode* p) {
    if (!p || !p-&gt;next) return;
    ListNode* doomed = p-&gt;next;
    p-&gt;next = doomed-&gt;next;
    delete doomed;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
                    <pre><code class="language-java">// Java
class ListNode {
    int val;
    ListNode next;
    ListNode(int v) { val = v; }
}

// Insert at head: return new head
ListNode insertHead(ListNode head, int x) {
    ListNode node = new ListNode(x);
    node.next = head;
    return node;
}

// Insert after node p (if non-null)
void insertAfter(ListNode p, int x) {
    if (p == null) return;
    ListNode node = new ListNode(x);
    node.next = p.next;
    p.next = node;
}

// Delete node immediately after p
void deleteAfter(ListNode p) {
    if (p == null || p.next == null) return;
    ListNode doomed = p.next;
    p.next = doomed.next;
    // In Java, garbage collector reclaims doomed
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
                    <pre><code class="language-javascript">// JavaScript
class ListNode {
    constructor(val, next = null) {
        this.val = val;
        this.next = next;
    }
}

// Insert at head: return new head
function insertHead(head, x) {
    const node = new ListNode(x, head);
    return node;
}

function insertAfter(p, x) {
    if (!p) return;
    const node = new ListNode(x, p.next);
    p.next = node;
}

function deleteAfter(p) {
    if (!p || !p.next) return;
    const doomed = p.next;
    p.next = doomed.next;
    // doomed is now unreachable and will be GCed
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
                    <pre><code class="language-csharp">// C#
class ListNode {
    public int Val;
    public ListNode? Next;
    public ListNode(int val, ListNode? next = null) {
        Val = val;
        Next = next;
    }
}

ListNode InsertHead(ListNode? head, int x) {
    return new ListNode(x, head);
}

void InsertAfter(ListNode? p, int x) {
    if (p == null) return;
    var node = new ListNode(x, p.Next);
    p.Next = node;
}

void DeleteAfter(ListNode? p) {
    if (p == null || p.Next == null) return;
    var doomed = p.Next;
    p.Next = doomed.Next;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
                    <pre><code class="language-python"># Python
from typing import Optional

class ListNode:
    def __init__(self, val: int = 0, next: "Optional[ListNode]" = None) -&gt; None:
        self.val = val
        self.next = next

def insert_head(head: Optional[ListNode], x: int) -&gt; ListNode:
    return ListNode(x, head)

def insert_after(p: Optional[ListNode], x: int) -&gt; None:
    if p is None:
        return
    node = ListNode(x, p.next)
    p.next = node

def delete_after(p: Optional[ListNode]) -&gt; None:
    if p is None or p.next is None:
        return
    doomed = p.next
    p.next = doomed.next</code></pre>
                </div>

                <div class="complexity-note">
                    All three operations touch a constant number of pointers → time <strong>O(1)</strong>.
                    Extra space is also <strong>O(1)</strong> (aside from the node allocated on insert).
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 2 - Reverse a Singly Linked List                  -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 2 - Reverse a Singly Linked List</h2>
            <p>
                We reverse the list in-place by iterating once and flipping each node&apos;s
                <code>next</code> pointer to point backward. We maintain three pointers:
                <code>prev</code>, <code>curr</code>, and <code>next</code>.
            </p>

            <div class="code-example" data-example="s3p2">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 2</span>
                        <span class="meta">Iterative in-place reversal</span>
                    </div>
                    <button type="button" class="deep-dive-trigger" data-deep-id="understand-s3p2">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
                    <pre><code class="language-c">// C
typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

ListNode* reverse_list(ListNode* head) {
    ListNode* prev = NULL;
    ListNode* curr = head;

    while (curr != NULL) {
        ListNode* nxt = curr-&gt;next;
        curr-&gt;next = prev;
        prev = curr;
        curr = nxt;
    }
    return prev;
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
                    <pre><code class="language-cpp">// C++
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int v) : val(v), next(nullptr) {}
};

ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;

    while (curr != nullptr) {
        ListNode* nxt = curr-&gt;next;
        curr-&gt;next = prev;
        prev = curr;
        curr = nxt;
    }
    return prev;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
                    <pre><code class="language-java">// Java
class ListNode {
    int val;
    ListNode next;
    ListNode(int v) { val = v; }
}

ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;

    while (curr != null) {
        ListNode nxt = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nxt;
    }
    return prev;
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
                    <pre><code class="language-javascript">// JavaScript
class ListNode {
    constructor(val, next = null) {
        this.val = val;
        this.next = next;
    }
}

function reverseList(head) {
    let prev = null;
    let curr = head;

    while (curr !== null) {
        const nxt = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nxt;
    }
    return prev;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
                    <pre><code class="language-csharp">// C#
class ListNode {
    public int Val;
    public ListNode? Next;
    public ListNode(int val) { Val = val; }
}

ListNode? ReverseList(ListNode? head) {
    ListNode? prev = null;
    ListNode? curr = head;

    while (curr != null) {
        var nxt = curr.Next;
        curr.Next = prev;
        prev = curr;
        curr = nxt;
    }
    return prev;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
                    <pre><code class="language-python"># Python
from typing import Optional

class ListNode:
    def __init__(self, val: int = 0,
                 next: "Optional[ListNode]" = None) -&gt; None:
        self.val = val
        self.next = next

def reverse_list(head: Optional[ListNode]) -&gt; Optional[ListNode]:
    prev: Optional[ListNode] = None
    curr = head
    while curr is not None:
        nxt = curr.next
        curr.next = prev
        prev = curr
        curr = nxt
    return prev</code></pre>
                </div>

                <div class="complexity-note">
                    We visit each node once → time <strong>O(n)</strong>.
                    We only use a few pointers → extra space <strong>O(1)</strong>.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 3 - Detect a Cycle (Floyd's Tortoise and Hare)    -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 3 - Detect a Cycle (Floyd&apos;s Tortoise and Hare)</h2>
            <p>
                Use two pointers: one moves one step at a time (slow), the other moves two steps
                at a time (fast). If a cycle exists, they will eventually meet. If fast hits
                <code>NULL</code>, there is no cycle.
            </p>

            <div class="code-example" data-example="s3p3">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 3</span>
                        <span class="meta">Floyd&apos;s cycle detection</span>
                    </div>
                    <button type="button" class="deep-dive-trigger" data-deep-id="understand-s3p3">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
                    <pre><code class="language-c">// C
#include &lt;stdbool.h&gt;

typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

bool has_cycle(ListNode* head) {
    if (head == NULL) return false;
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast != NULL &amp;&amp; fast-&gt;next != NULL) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
        if (slow == fast) return true;
    }
    return false;
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
                    <pre><code class="language-cpp">// C++
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int v) : val(v), next(nullptr) {}
};

bool hasCycle(ListNode* head) {
    if (!head) return false;
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast &amp;&amp; fast-&gt;next) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
        if (slow == fast) return true;
    }
    return false;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
                    <pre><code class="language-java">// Java
class ListNode {
    int val;
    ListNode next;
    ListNode(int v) { val = v; }
}

boolean hasCycle(ListNode head) {
    if (head == null) return false;
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null &amp;&amp; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) return true;
    }
    return false;
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
                    <pre><code class="language-javascript">// JavaScript
class ListNode {
    constructor(val, next = null) {
        this.val = val;
        this.next = next;
    }
}

function hasCycle(head) {
    if (!head) return false;
    let slow = head;
    let fast = head;
    while (fast !== null &amp;&amp; fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow === fast) return true;
    }
    return false;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
                    <pre><code class="language-csharp">// C#
class ListNode {
    public int Val;
    public ListNode? Next;
    public ListNode(int val) { Val = val; }
}

bool HasCycle(ListNode? head) {
    if (head == null) return false;
    var slow = head;
    var fast = head;
    while (fast != null &amp;&amp; fast.Next != null) {
        slow = slow!.Next!;
        fast = fast.Next.Next!;
        if (slow == fast) return true;
    }
    return false;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
                    <pre><code class="language-python"># Python
from typing import Optional

class ListNode:
    def __init__(self, val: int = 0,
                 next: "Optional[ListNode]" = None) -&gt; None:
        self.val = val
        self.next = next

def has_cycle(head: Optional[ListNode]) -&gt; bool:
    if head is None:
        return False
    slow = head
    fast = head
    while fast is not None and fast.next is not None:
        slow = slow.next
        fast = fast.next.next
        if slow is fast:
            return True
    return False</code></pre>
                </div>

                <div class="complexity-note">
                    Both pointers traverse at most a constant multiple of the list length →
                    time <strong>O(n)</strong>. Extra space is just a few pointers → <strong>O(1)</strong>.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 4 - Find the Middle of a Linked List              -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 4 - Find the Middle of a Linked List</h2>
            <p>
                Use slow/fast pointers again. Slow moves one step each iteration, fast moves two.
                When fast reaches the end, slow is at the middle. With this pattern, for even-length
                lists we return the second middle node by convention.
            </p>

            <div class="code-example" data-example="s3p4">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 4</span>
                        <span class="meta">Slow/fast pointers to find middle</span>
                    </div>
                    <button type="button" class="deep-dive-trigger" data-deep-id="understand-s3p4">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
                    <pre><code class="language-c">// C
typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

ListNode* middle_node(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast != NULL &amp;&amp; fast-&gt;next != NULL) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }
    return slow;
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
                    <pre><code class="language-cpp">// C++
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int v) : val(v), next(nullptr) {}
};

ListNode* middleNode(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast &amp;&amp; fast-&gt;next) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }
    return slow;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
                    <pre><code class="language-java">// Java
class ListNode {
    int val;
    ListNode next;
    ListNode(int v) { val = v; }
}

ListNode middleNode(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;

    while (fast != null &amp;&amp; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
                    <pre><code class="language-javascript">// JavaScript
class ListNode {
    constructor(val, next = null) {
        this.val = val;
        this.next = next;
    }
}

function middleNode(head) {
    let slow = head;
    let fast = head;

    while (fast !== null &amp;&amp; fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
                    <pre><code class="language-csharp">// C#
class ListNode {
    public int Val;
    public ListNode? Next;
    public ListNode(int val) { Val = val; }
}

ListNode? MiddleNode(ListNode? head) {
    var slow = head;
    var fast = head;

    while (fast != null &amp;&amp; fast.Next != null) {
        slow = slow!.Next;
        fast = fast.Next.Next;
    }
    return slow;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
                    <pre><code class="language-python"># Python
from typing import Optional

class ListNode:
    def __init__(self, val: int = 0,
                 next: "Optional[ListNode]" = None) -&gt; None:
        self.val = val
        self.next = next

def middle_node(head: Optional[ListNode]) -&gt; Optional[ListNode]:
    slow = head
    fast = head
    while fast is not None and fast.next is not None:
        slow = slow.next
        fast = fast.next.next
    return slow</code></pre>
                </div>

                <div class="complexity-note">
                    Each pointer traverses at most O(n) steps → time <strong>O(n)</strong>.
                    Extra space is constant → <strong>O(1)</strong>.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 5 - Merge Two Sorted Linked Lists                 -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 5 - Merge Two Sorted Linked Lists</h2>
            <p>
                Use a dummy head and a tail pointer. At each step, compare the current nodes
                from <code>l1</code> and <code>l2</code>, attach the smaller one to
                <code>tail</code>, and advance that list. At the end, attach the remainder.
            </p>

            <div class="code-example" data-example="s3p5">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 5</span>
                        <span class="meta">Dummy head plus tail pointer</span>
                    </div>
                    <button type="button" class="deep-dive-trigger" data-deep-id="understand-s3p5">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
                    <pre><code class="language-c">// C
typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

ListNode* merge_two_lists(ListNode* l1, ListNode* l2) {
    ListNode dummy;
    dummy.next = NULL;
    ListNode* tail = &amp;dummy;

    ListNode* a = l1;
    ListNode* b = l2;
    while (a != NULL &amp;&amp; b != NULL) {
        if (a-&gt;val &lt;= b-&gt;val) {
            tail-&gt;next = a;
            a = a-&gt;next;
        } else {
            tail-&gt;next = b;
            b = b-&gt;next;
        }
        tail = tail-&gt;next;
    }
    if (a != NULL) tail-&gt;next = a;
    if (b != NULL) tail-&gt;next = b;

    return dummy.next;
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
                    <pre><code class="language-cpp">// C++
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int v) : val(v), next(nullptr) {}
};

ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    ListNode dummy(0);
    ListNode* tail = &amp;dummy;

    ListNode* a = l1;
    ListNode* b = l2;
    while (a &amp;&amp; b) {
        if (a-&gt;val &lt;= b-&gt;val) {
            tail-&gt;next = a;
            a = a-&gt;next;
        } else {
            tail-&gt;next = b;
            b = b-&gt;next;
        }
        tail = tail-&gt;next;
    }
    if (a) tail-&gt;next = a;
    if (b) tail-&gt;next = b;

    return dummy.next;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
                    <pre><code class="language-java">// Java
class ListNode {
    int val;
    ListNode next;
    ListNode(int v) { val = v; }
}

ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode tail = dummy;

    ListNode a = l1;
    ListNode b = l2;
    while (a != null &amp;&amp; b != null) {
        if (a.val &lt;= b.val) {
            tail.next = a;
            a = a.next;
        } else {
            tail.next = b;
            b = b.next;
        }
        tail = tail.next;
    }
    if (a != null) tail.next = a;
    if (b != null) tail.next = b;

    return dummy.next;
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
                    <pre><code class="language-javascript">// JavaScript
class ListNode {
    constructor(val, next = null) {
        this.val = val;
        this.next = next;
    }
}

function mergeTwoLists(l1, l2) {
    const dummy = new ListNode(0);
    let tail = dummy;

    let a = l1;
    let b = l2;
    while (a !== null &amp;&amp; b !== null) {
        if (a.val &lt;= b.val) {
            tail.next = a;
            a = a.next;
        } else {
            tail.next = b;
            b = b.next;
        }
        tail = tail.next;
    }
    if (a !== null) tail.next = a;
    if (b !== null) tail.next = b;

    return dummy.next;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
                    <pre><code class="language-csharp">// C#
class ListNode {
    public int Val;
    public ListNode? Next;
    public ListNode(int val) { Val = val; }
}

ListNode? MergeTwoLists(ListNode? l1, ListNode? l2) {
    var dummy = new ListNode(0);
    var tail = dummy;

    var a = l1;
    var b = l2;
    while (a != null &amp;&amp; b != null) {
        if (a.Val &lt;= b.Val) {
            tail.Next = a;
            a = a.Next;
        } else {
            tail.Next = b;
            b = b.Next;
        }
        tail = tail.Next!;
    }
    if (a != null) tail.Next = a;
    if (b != null) tail.Next = b;

    return dummy.Next;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
                    <pre><code class="language-python"># Python
from typing import Optional

class ListNode:
    def __init__(self, val: int = 0,
                 next: "Optional[ListNode]" = None) -&gt; None:
        self.val = val
        self.next = next

def merge_two_lists(l1: Optional[ListNode],
                    l2: Optional[ListNode]) -&gt; Optional[ListNode]:
    dummy = ListNode(0)
    tail = dummy

    a = l1
    b = l2
    while a is not None and b is not None:
        if a.val &lt;= b.val:
            tail.next = a
            a = a.next
        else:
            tail.next = b
            b = b.next
        tail = tail.next
    if a is not None:
        tail.next = a
    if b is not None:
        tail.next = b

    return dummy.next</code></pre>
                </div>

                <div class="complexity-note">
                    Each node from both lists is processed exactly once →
                    time <strong>O(n + m)</strong>. We only use a few pointers →
                    extra space <strong>O(1)</strong>.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 6 - Remove N-th Node From the End                 -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 6 - Remove N-th Node From the End</h2>
            <p>
                Use a dummy head and two pointers. Advance the fast pointer
                <code>n + 1</code> steps ahead of slow so there is a gap of
                <code>n</code> nodes. Then move both until fast hits the end.
                Slow will be just before the node to remove.
            </p>

            <div class="code-example" data-example="s3p6">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 6</span>
                        <span class="meta">One-pass two-pointer removal</span>
                    </div>
                    <button type="button" class="deep-dive-trigger" data-deep-id="understand-s3p6">
                        Understand the Algorithm
                    </button>
                    <button type="button" class="copy-button" aria-label="Copy code">
                        Copy
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
                    <pre><code class="language-c">// C
typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

ListNode* remove_nth_from_end(ListNode* head, int n) {
    ListNode dummy;
    dummy.val = 0;
    dummy.next = head;

    ListNode* fast = &amp;dummy;
    ListNode* slow = &amp;dummy;

    for (int i = 0; i &lt;= n; i++) {
        if (fast == NULL) return head; // n too large
        fast = fast-&gt;next;
    }

    while (fast != NULL) {
        fast = fast-&gt;next;
        slow = slow-&gt;next;
    }

    ListNode* doomed = slow-&gt;next;
    if (doomed != NULL) {
        slow-&gt;next = doomed-&gt;next;
        free(doomed);
    }
    return dummy.next;
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
                    <pre><code class="language-cpp">// C++
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int v) : val(v), next(nullptr) {}
};

ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode dummy(0);
    dummy.next = head;
    ListNode* fast = &amp;dummy;
    ListNode* slow = &amp;dummy;

    for (int i = 0; i &lt;= n; i++) {
        if (!fast) return head; // n too large
        fast = fast-&gt;next;
    }

    while (fast) {
        fast = fast-&gt;next;
        slow = slow-&gt;next;
    }

    ListNode* doomed = slow-&gt;next;
    slow-&gt;next = doomed-&gt;next;
    delete doomed;

    return dummy.next;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
                    <pre><code class="language-java">// Java
class ListNode {
    int val;
    ListNode next;
    ListNode(int v) { val = v; }
}

ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode fast = dummy;
    ListNode slow = dummy;

    for (int i = 0; i &lt;= n; i++) {
        if (fast == null) return head; // n too large
        fast = fast.next;
    }

    while (fast != null) {
        fast = fast.next;
        slow = slow.next;
    }

    ListNode doomed = slow.next;
    slow.next = doomed.next;
    // doomed node is eventually GCed

    return dummy.next;
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
                    <pre><code class="language-javascript">// JavaScript
class ListNode {
    constructor(val, next = null) {
        this.val = val;
        this.next = next;
    }
}

function removeNthFromEnd(head, n) {
    const dummy = new ListNode(0, head);
    let fast = dummy;
    let slow = dummy;

    for (let i = 0; i &lt;= n; i++) {
        if (fast === null) return head; // n too large
        fast = fast.next;
    }

    while (fast !== null) {
        fast = fast.next;
        slow = slow.next;
    }

    const doomed = slow.next;
    if (doomed !== null) {
        slow.next = doomed.next;
    }
    return dummy.next;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
                    <pre><code class="language-csharp">// C#
class ListNode {
    public int Val;
    public ListNode? Next;
    public ListNode(int val) { Val = val; }
}

ListNode? RemoveNthFromEnd(ListNode? head, int n) {
    var dummy = new ListNode(0) { Next = head };
    var fast = dummy;
    var slow = dummy;

    for (int i = 0; i &lt;= n; i++) {
        if (fast == null) return head; // n too large
        fast = fast.Next!;
    }

    while (fast != null) {
        fast = fast.Next!;
        slow = slow.Next!;
    }

    var doomed = slow.Next;
    if (doomed != null) {
        slow.Next = doomed.Next;
    }
    return dummy.Next;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
                    <pre><code class="language-python"># Python
from typing import Optional

class ListNode:
    def __init__(self, val: int = 0,
                 next: "Optional[ListNode]" = None) -&gt; None:
        self.val = val
        self.next = next

def remove_nth_from_end(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:
    dummy = ListNode(0, head)
    fast: Optional[ListNode] = dummy
    slow: Optional[ListNode] = dummy

    for _ in range(n + 1):
        if fast is None:
            return head
        fast = fast.next

    while fast is not None:
        fast = fast.next
        slow = slow.next  # type: ignore[assignment]

    doomed = slow.next  # type: ignore[assignment]
    if doomed is not None:
        slow.next = doomed.next  # type: ignore[assignment]
    return dummy.next</code></pre>
                </div>

                <div class="complexity-note">
                    We traverse the list with a single pass (fast and slow) →
                    time <strong>O(n)</strong>. We only use a few pointers and a dummy node →
                    extra space <strong>O(1)</strong>.
                </div>
            </div>
        </section>

        <div class="next-section">
            <a href="problems-section3-linked-lists.html">
                ← Back to Section 3 Problem Set
            </a>
            &nbsp;&nbsp;
            <a href="section10-practice.html">
                Back to Practice Hub →
            </a>
        </div>

        <!-- ======================= Understand-the-algorithm templates ======================= -->

        <div class="deep-dive-template" id="understand-s3p1"
            data-title="Step-by-step: Basic singly linked list operations" hidden>
            <p>
                All three operations are <strong>O(1)</strong> because you already have a pointer to the place you want
                to
                modify. That means you don’t search the list — you only <strong>rewire one or two <code>next</code>
                    pointers</strong>.
            </p>

            <h3>Core rule: don’t lose the rest of the list</h3>
            <p>
                Any time you overwrite a <code>next</code> pointer, first save (or reuse) the pointer that leads to the
                rest of
                the chain. Most bugs happen when you accidentally “drop” the only reference to the remainder.
            </p>

            <h3>1) Insert at head</h3>
            <p><strong>Goal:</strong> turn <code>head → ...</code> into <code>new → head → ...</code>.</p>
            <ol>
                <li><strong>Create a new node</strong> and set <code>node.val = x</code>.</li>
                <li>
                    <strong>Point the new node at the old head</strong>:
                    <code>node.next = head</code>.
                    <p class="small">
                        This preserves the original list by keeping a reference to its first node.
                    </p>
                </li>
                <li>
                    <strong>Update head to the new node</strong>.
                    <p class="small">
                        In C this requires a pointer-to-pointer (<code>ListNode**</code>) or returning the new head.
                    </p>
                </li>
            </ol>

            <h3>2) Insert after a given node <code>p</code></h3>
            <p><strong>Goal:</strong> change <code>p → oldNext</code> into <code>p → node → oldNext</code>.</p>
            <ol>
                <li><strong>Validate <code>p</code></strong>. If <code>p</code> is null, there’s no insertion point.
                </li>
                <li><strong>Create the new node</strong> with value <code>x</code>.</li>
                <li>
                    <strong>Wire the new node to the remainder first</strong>:
                    <code>node.next = p.next</code>.
                    <p class="small">
                        This step prevents losing the tail of the list when you update <code>p.next</code>.
                    </p>
                </li>
                <li><strong>Complete the splice</strong>: set <code>p.next = node</code>.</li>
            </ol>

            <h3>3) Delete the node immediately after <code>p</code></h3>
            <p><strong>Goal:</strong> bypass the next node: <code>p → doomed → after</code> becomes
                <code>p → after</code>.</p>
            <ol>
                <li><strong>Validate pointers</strong>: if <code>p</code> is null or <code>p.next</code> is null, there
                    is nothing to delete.</li>
                <li><strong>Save the node to remove</strong>: <code>doomed = p.next</code>.</li>
                <li>
                    <strong>Bypass it</strong>:
                    <code>p.next = doomed.next</code>.
                    <p class="small">
                        After this line, the list no longer references <code>doomed</code>.
                    </p>
                </li>
                <li>
                    <strong>Free / drop the node</strong>:
                    <ul>
                        <li>C/C++: <code>free(doomed)</code> / <code>delete doomed</code></li>
                        <li>GC languages: letting it become unreachable is enough</li>
                    </ul>
                </li>
            </ol>

            <h3>Why all three are O(1)</h3>
            <p>
                None of these operations require traversal from the head. You only touch a constant number of nodes and
                pointers.
            </p>
        </div>

        <div class="deep-dive-template" id="understand-s3p2"
            data-title="Step-by-step: Reverse a singly linked list in-place" hidden>
            <p>
                Reversing a list means flipping every <code>next</code> pointer so it points backward.
                The challenge is doing that without losing your only reference to the remaining nodes.
            </p>

            <h3>The invariant (the thing you keep true)</h3>
            <ul>
                <li><code>prev</code> is the head of the <strong>already-reversed</strong> prefix.</li>
                <li><code>curr</code> is the head of the <strong>not-yet-processed</strong> suffix.</li>
            </ul>

            <h3>Why we need three pointers</h3>
            <p>
                The moment you do <code>curr.next = prev</code>, the original forward link is gone.
                So you must save it first in <code>nxt</code>.
            </p>

            <h3>Loop steps</h3>
            <ol>
                <li><strong>Save the remainder</strong>: <code>nxt = curr.next</code></li>
                <li><strong>Reverse the link</strong>: <code>curr.next = prev</code></li>
                <li><strong>Advance the reversed prefix</strong>: <code>prev = curr</code></li>
                <li><strong>Advance into the remainder</strong>: <code>curr = nxt</code></li>
            </ol>

            <h3>Finish</h3>
            <p>
                When <code>curr</code> becomes null, you’ve processed every node. <code>prev</code> is now the new head.
            </p>

            <h3>Complexity</h3>
            <ul>
                <li><strong>Time:</strong> O(n) — each node is visited once.</li>
                <li><strong>Extra space:</strong> O(1) — only a few pointers are used.</li>
            </ul>

            <h3>Common bug to watch for</h3>
            <p>
                Forgetting to save <code>curr.next</code> before overwriting it causes the rest of the list to be lost.
            </p>
        </div>

        <div class="deep-dive-template" id="understand-s3p3"
            data-title="Step-by-step: Detect a cycle with Floyd's tortoise and hare" hidden>
            <p>
                Floyd’s algorithm uses two pointers moving at different speeds to detect whether the list loops.
                It meets the requirement of <strong>O(1)</strong> extra space.
            </p>

            <h3>Pointer rules</h3>
            <ul>
                <li><code>slow</code> moves 1 step per loop: <code>slow = slow.next</code></li>
                <li><code>fast</code> moves 2 steps per loop: <code>fast = fast.next.next</code></li>
            </ul>

            <h3>Stopping cases</h3>
            <ol>
                <li>
                    <strong>No cycle:</strong> if <code>fast</code> hits null, the list has an end, so no cycle.
                    <p class="small">
                        In code you check <code>fast != null && fast.next != null</code> before advancing two steps.
                    </p>
                </li>
                <li>
                    <strong>Cycle exists:</strong> if <code>slow == fast</code> at any point, they have met inside a
                    loop.
                </li>
            </ol>

            <h3>Why they meet (intuition)</h3>
            <p>
                Once both pointers are inside the cycle, think of the cycle as a circle. Each loop iteration,
                <code>fast</code> gains one node of distance on <code>slow</code>. Gaining 1 repeatedly on a finite
                circle
                guarantees landing on the same node eventually.
            </p>

            <h3>Complexity</h3>
            <ul>
                <li><strong>Time:</strong> O(n) — in the worst case, pointers traverse a constant multiple of the list
                    length.</li>
                <li><strong>Extra space:</strong> O(1) — only two pointers.</li>
            </ul>
        </div>

        <div class="deep-dive-template" id="understand-s3p4"
            data-title="Step-by-step: Find the middle node with slow/fast pointers" hidden>
            <p>
                This uses the same slow/fast idea as cycle detection, but instead of looking for a meeting point,
                you stop when the fast pointer reaches the end.
            </p>

            <h3>Pointer rules</h3>
            <ul>
                <li><code>slow</code> moves 1 step</li>
                <li><code>fast</code> moves 2 steps</li>
            </ul>

            <h3>Why slow ends at the middle</h3>
            <p>
                For every 2 nodes <code>fast</code> advances, <code>slow</code> advances 1. So when <code>fast</code>
                has covered the whole list, <code>slow</code> has covered half.
            </p>

            <h3>Even-length convention (return the second middle)</h3>
            <p>
                With the standard loop condition <code>while (fast != null && fast.next != null)</code>,
                <code>slow</code> lands on the <strong>second</strong> middle node in an even-length list
                (e.g., 1→2→3→4 returns 3). This matches many interview/LeetCode conventions.
            </p>

            <h3>Complexity</h3>
            <ul>
                <li><strong>Time:</strong> O(n)</li>
                <li><strong>Extra space:</strong> O(1)</li>
            </ul>
        </div>

        <div class="deep-dive-template" id="understand-s3p5" data-title="Step-by-step: Merge two sorted linked lists"
            hidden>
            <p>
                This is the linked-list version of the merge step in merge sort. You repeatedly take the smaller
                front element and append it to the merged list.
            </p>

            <h3>Why a dummy head helps</h3>
            <p>
                A <strong>dummy</strong> node removes special cases for the first insertion. You always append to
                <code>tail.next</code> and move <code>tail</code> forward.
            </p>

            <h3>Algorithm</h3>
            <ol>
                <li><strong>Initialize</strong> <code>dummy</code> and set <code>tail = dummy</code>.</li>
                <li><strong>Walk</strong> two pointers <code>a = l1</code> and <code>b = l2</code>.</li>
                <li>
                    While both are non-null:
                    <ul>
                        <li>Compare <code>a.val</code> and <code>b.val</code>.</li>
                        <li>Attach the smaller node to <code>tail.next</code>.</li>
                        <li>Advance whichever list you took from.</li>
                        <li>Advance <code>tail</code>.</li>
                    </ul>
                </li>
                <li>
                    <strong>Attach the remainder</strong>:
                    whichever list is not finished is already sorted, so append it directly.
                </li>
                <li><strong>Return</strong> <code>dummy.next</code> as the real head.</li>
            </ol>

            <h3>Invariants</h3>
            <ul>
                <li>The list starting at <code>dummy.next</code> is always sorted.</li>
                <li><code>tail</code> always points to the last node of the merged list.</li>
            </ul>

            <h3>Complexity</h3>
            <ul>
                <li><strong>Time:</strong> O(n + m) — each node from both lists is used once.</li>
                <li><strong>Extra space:</strong> O(1) — reuses nodes; dummy is constant overhead.</li>
            </ul>
        </div>

        <div class="deep-dive-template" id="understand-s3p6"
            data-title="Step-by-step: Remove the N-th node from the end in one pass" hidden>
            <p>
                The trick is to create a fixed gap of <code>n</code> nodes between two pointers. When the fast pointer
                hits the end, the slow pointer is positioned just before the node to remove.
            </p>

            <h3>Why a dummy head is important</h3>
            <p>
                If the node to remove is the original head, you need a way to “remove head” cleanly.
                A <code>dummy</code> node means you always remove <code>slow.next</code>, even when the real head
                changes.
            </p>

            <h3>Algorithm</h3>
            <ol>
                <li><strong>Create</strong> <code>dummy → head</code>. Set <code>fast = dummy</code>,
                    <code>slow = dummy</code>.</li>
                <li>
                    <strong>Advance fast</strong> by <code>n + 1</code> steps.
                    <p class="small">
                        After this, there is a gap of exactly <code>n</code> nodes between <code>slow</code> and
                        <code>fast</code>.
                    </p>
                </li>
                <li>
                    <strong>Move both</strong> until <code>fast</code> becomes null.
                    <p class="small">
                        Now <code>slow</code> is immediately before the target node.
                    </p>
                </li>
                <li>
                    <strong>Remove</strong> <code>slow.next</code> by bypassing it:
                    <code>slow.next = slow.next.next</code>.
                    <p class="small">
                        In C/C++, free/delete the removed node.
                    </p>
                </li>
                <li><strong>Return</strong> <code>dummy.next</code>.</li>
            </ol>

            <h3>Invariants</h3>
            <ul>
                <li>The gap between <code>fast</code> and <code>slow</code> stays constant after setup.</li>
                <li>When <code>fast</code> is null, <code>slow</code> is just before the node to delete.</li>
            </ul>

            <h3>Complexity</h3>
            <ul>
                <li><strong>Time:</strong> O(n) — one pass.</li>
                <li><strong>Extra space:</strong> O(1) — a few pointers plus a dummy node.</li>
            </ul>

            <h3>Common edge cases</h3>
            <ul>
                <li><code>n</code> equals list length → remove the head</li>
                <li>single-node list</li>
                <li><code>n</code> larger than list length (if you choose to guard against it)</li>
            </ul>
        </div>

        <!-- ======================= Modal shell reused by all buttons ======================= -->

        <div class="deep-dive-backdrop" id="deep-dive-backdrop" aria-hidden="true">
            <div class="deep-dive-modal" role="dialog" aria-modal="true" aria-labelledby="deep-dive-title">
                <button type="button" class="deep-dive-close" aria-label="Close">&times;</button>
                <h2 id="deep-dive-title">&nbsp;</h2>
                <div class="deep-dive-body"></div>
            </div>
        </div>

    </main>
</body>

</html>
