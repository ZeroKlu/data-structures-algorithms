<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Solutions - Section 3 Linked Lists</title>

    <!-- Site styles -->
    <link rel="stylesheet" href="css/site.css">

    <!-- Highlight.js theme (initial, can be changed via selector) -->
    <link id="hljs-theme" rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

    <!-- highlight.js core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- highlight.js languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

    <!-- Site scripts (tabs, highlight init, prefs, cookies, etc.) -->
    <script src="js/site.js"></script>

    <!-- Favicon -->
    <link rel="icon" href="img/icon.svg" type="image/svg+xml" sizes="any">
</head>

<body>
    <main>
        <div class="top-nav">
            <a href="section10-practice.html">← Back to Practice Hub</a>
            &nbsp;&nbsp;
            <a href="problems-section3-linked-lists.html">← Back to Section 3 Problems</a>
            &nbsp;&nbsp;
            <a href="section3-linked-lists.html">View Section 3 Lesson →</a>
        </div>

        <div class="kicker">Section 3 - Solutions</div>
        <h1>Linked Lists - Detailed Solutions</h1>
        <p class="tagline">
            Multi-language implementations for core linked list patterns:
            basic pointer operations, reversal, cycle detection, middle-of-list,
            merging sorted lists, and removing the N-th node from the end.
        </p>

        <div class="theme-picker">
            <label for="theme-select">Syntax theme:</label>
            <select id="theme-select">
                <option value="atom-one-dark">Dark</option>
                <option value="far">Blue</option>
                <option value="atom-one-light">Light</option>
            </select>
        </div>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 1 - Basic Singly Linked List Operations           -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 1 - Basic Singly Linked List Operations</h2>
            <p>
                We assume the node definition:
            </p>
<pre><code class="language-c">typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;</code></pre>

            <p>
                We want to implement three operations:
            </p>
            <ol>
                <li>Insert a new node with value <code>x</code> at the head.</li>
                <li>Insert a new node with value <code>x</code> after a given node <code>p</code>.</li>
                <li>Delete the node immediately after a given node <code>p</code> (if it exists).</li>
            </ol>
            <p>
                The key idea is that if we already have a pointer to the correct place, we only
                need to adjust a constant number of pointers, independent of the list length.
            </p>

            <div class="code-example" data-example="s3p1">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 1</span>
                        <span class="meta">Insert-head, insert-after, delete-after</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s3p1">
                        Understand the Algorithm
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C
#include &lt;stdlib.h&gt;

typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

// Insert at head: head pointer is updated via pointer-to-pointer
void insert_head(ListNode** head, int x) {
    ListNode* node = (ListNode*)malloc(sizeof(ListNode));
    node-&gt;val = x;
    node-&gt;next = *head;
    *head = node;
}

// Insert after node p (if p is non-NULL)
void insert_after(ListNode* p, int x) {
    if (!p) return;
    ListNode* node = (ListNode*)malloc(sizeof(ListNode));
    node-&gt;val = x;
    node-&gt;next = p-&gt;next;
    p-&gt;next = node;
}

// Delete node immediately after p (if it exists)
void delete_after(ListNode* p) {
    if (!p || !p-&gt;next) return;
    ListNode* doomed = p-&gt;next;
    p-&gt;next = doomed-&gt;next;
    free(doomed);
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
#include &lt;cstdlib&gt;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int v) : val(v), next(nullptr) {}
};

// Insert at head: modify head by reference
void insertHead(ListNode*& head, int x) {
    ListNode* node = new ListNode(x);
    node-&gt;next = head;
    head = node;
}

// Insert after p
void insertAfter(ListNode* p, int x) {
    if (!p) return;
    ListNode* node = new ListNode(x);
    node-&gt;next = p-&gt;next;
    p-&gt;next = node;
}

// Delete after p
void deleteAfter(ListNode* p) {
    if (!p || !p-&gt;next) return;
    ListNode* doomed = p-&gt;next;
    p-&gt;next = doomed-&gt;next;
    delete doomed;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
class ListNode {
    int val;
    ListNode next;
    ListNode(int v) { val = v; }
}

// Insert at head: return new head
ListNode insertHead(ListNode head, int x) {
    ListNode node = new ListNode(x);
    node.next = head;
    return node;
}

// Insert after node p (if non-null)
void insertAfter(ListNode p, int x) {
    if (p == null) return;
    ListNode node = new ListNode(x);
    node.next = p.next;
    p.next = node;
}

// Delete node immediately after p
void deleteAfter(ListNode p) {
    if (p == null || p.next == null) return;
    ListNode doomed = p.next;
    p.next = doomed.next;
    // In Java, garbage collector reclaims doomed
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
class ListNode {
    constructor(val, next = null) {
        this.val = val;
        this.next = next;
    }
}

// Insert at head: return new head
function insertHead(head, x) {
    const node = new ListNode(x, head);
    return node;
}

function insertAfter(p, x) {
    if (!p) return;
    const node = new ListNode(x, p.next);
    p.next = node;
}

function deleteAfter(p) {
    if (!p || !p.next) return;
    const doomed = p.next;
    p.next = doomed.next;
    // doomed is now unreachable and will be GCed
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
class ListNode {
    public int Val;
    public ListNode? Next;
    public ListNode(int val, ListNode? next = null) {
        Val = val;
        Next = next;
    }
}

ListNode InsertHead(ListNode? head, int x) {
    return new ListNode(x, head);
}

void InsertAfter(ListNode? p, int x) {
    if (p == null) return;
    var node = new ListNode(x, p.Next);
    p.Next = node;
}

void DeleteAfter(ListNode? p) {
    if (p == null || p.Next == null) return;
    var doomed = p.Next;
    p.Next = doomed.Next;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
from typing import Optional

class ListNode:
    def __init__(self, val: int = 0, next: "Optional[ListNode]" = None) -&gt; None:
        self.val = val
        self.next = next

def insert_head(head: Optional[ListNode], x: int) -&gt; ListNode:
    return ListNode(x, head)

def insert_after(p: Optional[ListNode], x: int) -&gt; None:
    if p is None:
        return
    node = ListNode(x, p.next)
    p.next = node

def delete_after(p: Optional[ListNode]) -&gt; None:
    if p is None or p.next is None:
        return
    doomed = p.next
    p.next = doomed.next</code></pre>
                </div>

                <div class="complexity-note">
                    All three operations touch a constant number of pointers → time <strong>O(1)</strong>.
                    Extra space is also <strong>O(1)</strong> (aside from the node allocated on insert).
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 2 - Reverse a Singly Linked List                  -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 2 - Reverse a Singly Linked List</h2>
            <p>
                We reverse the list in-place by iterating once and flipping each node&apos;s
                <code>next</code> pointer to point backward. We maintain three pointers:
                <code>prev</code>, <code>curr</code>, and <code>next</code>.
            </p>

            <div class="code-example" data-example="s3p2">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 2</span>
                        <span class="meta">Iterative in-place reversal</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s3p2">
                        Understand the Algorithm
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C
typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

ListNode* reverse_list(ListNode* head) {
    ListNode* prev = NULL;
    ListNode* curr = head;

    while (curr != NULL) {
        ListNode* nxt = curr-&gt;next;
        curr-&gt;next = prev;
        prev = curr;
        curr = nxt;
    }
    return prev;
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int v) : val(v), next(nullptr) {}
};

ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;

    while (curr != nullptr) {
        ListNode* nxt = curr-&gt;next;
        curr-&gt;next = prev;
        prev = curr;
        curr = nxt;
    }
    return prev;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
class ListNode {
    int val;
    ListNode next;
    ListNode(int v) { val = v; }
}

ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;

    while (curr != null) {
        ListNode nxt = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nxt;
    }
    return prev;
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
class ListNode {
    constructor(val, next = null) {
        this.val = val;
        this.next = next;
    }
}

function reverseList(head) {
    let prev = null;
    let curr = head;

    while (curr !== null) {
        const nxt = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nxt;
    }
    return prev;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
class ListNode {
    public int Val;
    public ListNode? Next;
    public ListNode(int val) { Val = val; }
}

ListNode? ReverseList(ListNode? head) {
    ListNode? prev = null;
    ListNode? curr = head;

    while (curr != null) {
        var nxt = curr.Next;
        curr.Next = prev;
        prev = curr;
        curr = nxt;
    }
    return prev;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
from typing import Optional

class ListNode:
    def __init__(self, val: int = 0,
                 next: "Optional[ListNode]" = None) -&gt; None:
        self.val = val
        self.next = next

def reverse_list(head: Optional[ListNode]) -&gt; Optional[ListNode]:
    prev: Optional[ListNode] = None
    curr = head
    while curr is not None:
        nxt = curr.next
        curr.next = prev
        prev = curr
        curr = nxt
    return prev</code></pre>
                </div>

                <div class="complexity-note">
                    We visit each node once → time <strong>O(n)</strong>.
                    We only use a few pointers → extra space <strong>O(1)</strong>.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 3 - Detect a Cycle (Floyd's Tortoise and Hare)    -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 3 - Detect a Cycle (Floyd&apos;s Tortoise and Hare)</h2>
            <p>
                Use two pointers: one moves one step at a time (slow), the other moves two steps
                at a time (fast). If a cycle exists, they will eventually meet. If fast hits
                <code>NULL</code>, there is no cycle.
            </p>

            <div class="code-example" data-example="s3p3">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 3</span>
                        <span class="meta">Floyd&apos;s cycle detection</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s3p3">
                        Understand the Algorithm
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C
#include &lt;stdbool.h&gt;

typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

bool has_cycle(ListNode* head) {
    if (head == NULL) return false;
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast != NULL &amp;&amp; fast-&gt;next != NULL) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
        if (slow == fast) return true;
    }
    return false;
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int v) : val(v), next(nullptr) {}
};

bool hasCycle(ListNode* head) {
    if (!head) return false;
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast &amp;&amp; fast-&gt;next) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
        if (slow == fast) return true;
    }
    return false;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
class ListNode {
    int val;
    ListNode next;
    ListNode(int v) { val = v; }
}

boolean hasCycle(ListNode head) {
    if (head == null) return false;
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null &amp;&amp; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) return true;
    }
    return false;
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
class ListNode {
    constructor(val, next = null) {
        this.val = val;
        this.next = next;
    }
}

function hasCycle(head) {
    if (!head) return false;
    let slow = head;
    let fast = head;
    while (fast !== null &amp;&amp; fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow === fast) return true;
    }
    return false;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
class ListNode {
    public int Val;
    public ListNode? Next;
    public ListNode(int val) { Val = val; }
}

bool HasCycle(ListNode? head) {
    if (head == null) return false;
    var slow = head;
    var fast = head;
    while (fast != null &amp;&amp; fast.Next != null) {
        slow = slow!.Next!;
        fast = fast.Next.Next!;
        if (slow == fast) return true;
    }
    return false;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
from typing import Optional

class ListNode:
    def __init__(self, val: int = 0,
                 next: "Optional[ListNode]" = None) -&gt; None:
        self.val = val
        self.next = next

def has_cycle(head: Optional[ListNode]) -&gt; bool:
    if head is None:
        return False
    slow = head
    fast = head
    while fast is not None and fast.next is not None:
        slow = slow.next
        fast = fast.next.next
        if slow is fast:
            return True
    return False</code></pre>
                </div>

                <div class="complexity-note">
                    Both pointers traverse at most a constant multiple of the list length →
                    time <strong>O(n)</strong>. Extra space is just a few pointers → <strong>O(1)</strong>.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 4 - Find the Middle of a Linked List              -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 4 - Find the Middle of a Linked List</h2>
            <p>
                Use slow/fast pointers again. Slow moves one step each iteration, fast moves two.
                When fast reaches the end, slow is at the middle. With this pattern, for even-length
                lists we return the second middle node by convention.
            </p>

            <div class="code-example" data-example="s3p4">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 4</span>
                        <span class="meta">Slow/fast pointers to find middle</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s3p4">
                        Understand the Algorithm
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C
typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

ListNode* middle_node(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast != NULL &amp;&amp; fast-&gt;next != NULL) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }
    return slow;
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int v) : val(v), next(nullptr) {}
};

ListNode* middleNode(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast &amp;&amp; fast-&gt;next) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }
    return slow;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
class ListNode {
    int val;
    ListNode next;
    ListNode(int v) { val = v; }
}

ListNode middleNode(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;

    while (fast != null &amp;&amp; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
class ListNode {
    constructor(val, next = null) {
        this.val = val;
        this.next = next;
    }
}

function middleNode(head) {
    let slow = head;
    let fast = head;

    while (fast !== null &amp;&amp; fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
class ListNode {
    public int Val;
    public ListNode? Next;
    public ListNode(int val) { Val = val; }
}

ListNode? MiddleNode(ListNode? head) {
    var slow = head;
    var fast = head;

    while (fast != null &amp;&amp; fast.Next != null) {
        slow = slow!.Next;
        fast = fast.Next.Next;
    }
    return slow;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
from typing import Optional

class ListNode:
    def __init__(self, val: int = 0,
                 next: "Optional[ListNode]" = None) -&gt; None:
        self.val = val
        self.next = next

def middle_node(head: Optional[ListNode]) -&gt; Optional[ListNode]:
    slow = head
    fast = head
    while fast is not None and fast.next is not None:
        slow = slow.next
        fast = fast.next.next
    return slow</code></pre>
                </div>

                <div class="complexity-note">
                    Each pointer traverses at most O(n) steps → time <strong>O(n)</strong>.
                    Extra space is constant → <strong>O(1)</strong>.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 5 - Merge Two Sorted Linked Lists                 -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 5 - Merge Two Sorted Linked Lists</h2>
            <p>
                Use a dummy head and a tail pointer. At each step, compare the current nodes
                from <code>l1</code> and <code>l2</code>, attach the smaller one to
                <code>tail</code>, and advance that list. At the end, attach the remainder.
            </p>

            <div class="code-example" data-example="s3p5">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 5</span>
                        <span class="meta">Dummy head plus tail pointer</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s3p5">
                        Understand the Algorithm
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C
typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

ListNode* merge_two_lists(ListNode* l1, ListNode* l2) {
    ListNode dummy;
    dummy.next = NULL;
    ListNode* tail = &amp;dummy;

    ListNode* a = l1;
    ListNode* b = l2;
    while (a != NULL &amp;&amp; b != NULL) {
        if (a-&gt;val &lt;= b-&gt;val) {
            tail-&gt;next = a;
            a = a-&gt;next;
        } else {
            tail-&gt;next = b;
            b = b-&gt;next;
        }
        tail = tail-&gt;next;
    }
    if (a != NULL) tail-&gt;next = a;
    if (b != NULL) tail-&gt;next = b;

    return dummy.next;
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int v) : val(v), next(nullptr) {}
};

ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    ListNode dummy(0);
    ListNode* tail = &amp;dummy;

    ListNode* a = l1;
    ListNode* b = l2;
    while (a &amp;&amp; b) {
        if (a-&gt;val &lt;= b-&gt;val) {
            tail-&gt;next = a;
            a = a-&gt;next;
        } else {
            tail-&gt;next = b;
            b = b-&gt;next;
        }
        tail = tail-&gt;next;
    }
    if (a) tail-&gt;next = a;
    if (b) tail-&gt;next = b;

    return dummy.next;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
class ListNode {
    int val;
    ListNode next;
    ListNode(int v) { val = v; }
}

ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode tail = dummy;

    ListNode a = l1;
    ListNode b = l2;
    while (a != null &amp;&amp; b != null) {
        if (a.val &lt;= b.val) {
            tail.next = a;
            a = a.next;
        } else {
            tail.next = b;
            b = b.next;
        }
        tail = tail.next;
    }
    if (a != null) tail.next = a;
    if (b != null) tail.next = b;

    return dummy.next;
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
class ListNode {
    constructor(val, next = null) {
        this.val = val;
        this.next = next;
    }
}

function mergeTwoLists(l1, l2) {
    const dummy = new ListNode(0);
    let tail = dummy;

    let a = l1;
    let b = l2;
    while (a !== null &amp;&amp; b !== null) {
        if (a.val &lt;= b.val) {
            tail.next = a;
            a = a.next;
        } else {
            tail.next = b;
            b = b.next;
        }
        tail = tail.next;
    }
    if (a !== null) tail.next = a;
    if (b !== null) tail.next = b;

    return dummy.next;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
class ListNode {
    public int Val;
    public ListNode? Next;
    public ListNode(int val) { Val = val; }
}

ListNode? MergeTwoLists(ListNode? l1, ListNode? l2) {
    var dummy = new ListNode(0);
    var tail = dummy;

    var a = l1;
    var b = l2;
    while (a != null &amp;&amp; b != null) {
        if (a.Val &lt;= b.Val) {
            tail.Next = a;
            a = a.Next;
        } else {
            tail.Next = b;
            b = b.Next;
        }
        tail = tail.Next!;
    }
    if (a != null) tail.Next = a;
    if (b != null) tail.Next = b;

    return dummy.Next;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
from typing import Optional

class ListNode:
    def __init__(self, val: int = 0,
                 next: "Optional[ListNode]" = None) -&gt; None:
        self.val = val
        self.next = next

def merge_two_lists(l1: Optional[ListNode],
                    l2: Optional[ListNode]) -&gt; Optional[ListNode]:
    dummy = ListNode(0)
    tail = dummy

    a = l1
    b = l2
    while a is not None and b is not None:
        if a.val &lt;= b.val:
            tail.next = a
            a = a.next
        else:
            tail.next = b
            b = b.next
        tail = tail.next
    if a is not None:
        tail.next = a
    if b is not None:
        tail.next = b

    return dummy.next</code></pre>
                </div>

                <div class="complexity-note">
                    Each node from both lists is processed exactly once →
                    time <strong>O(n + m)</strong>. We only use a few pointers →
                    extra space <strong>O(1)</strong>.
                </div>
            </div>
        </section>

        <hr>

        <!-- ========================================================= -->
        <!-- Problem 6 - Remove N-th Node From the End                 -->
        <!-- ========================================================= -->

        <section class="problem">
            <h2>Problem 6 - Remove N-th Node From the End</h2>
            <p>
                Use a dummy head and two pointers. Advance the fast pointer
                <code>n + 1</code> steps ahead of slow so there is a gap of
                <code>n</code> nodes. Then move both until fast hits the end.
                Slow will be just before the node to remove.
            </p>

            <div class="code-example" data-example="s3p6">
                <div class="code-example-header">
                    <div class="code-example-title">
                        <span class="label">Problem 6</span>
                        <span class="meta">One-pass two-pointer removal</span>
                    </div>
                    <button type="button" class="deep-dive-trigger"
                        data-deep-id="understand-s3p6">
                        Understand the Algorithm
                    </button>
                </div>

                <div class="tab-bar">
                    <button class="tab-button active" data-lang="c"><span class="dot"></span>C</button>
                    <button class="tab-button" data-lang="cpp"><span class="dot"></span>C++</button>
                    <button class="tab-button" data-lang="java"><span class="dot"></span>Java</button>
                    <button class="tab-button" data-lang="js"><span class="dot"></span>JavaScript</button>
                    <button class="tab-button" data-lang="cs"><span class="dot"></span>C#</button>
                    <button class="tab-button" data-lang="py"><span class="dot"></span>Python</button>
                </div>

                <!-- C -->
                <div class="code-panel" data-lang-panel="c">
<pre><code class="language-c">// C
typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

ListNode* remove_nth_from_end(ListNode* head, int n) {
    ListNode dummy;
    dummy.val = 0;
    dummy.next = head;

    ListNode* fast = &amp;dummy;
    ListNode* slow = &amp;dummy;

    for (int i = 0; i &lt;= n; i++) {
        if (fast == NULL) return head; // n too large
        fast = fast-&gt;next;
    }

    while (fast != NULL) {
        fast = fast-&gt;next;
        slow = slow-&gt;next;
    }

    ListNode* doomed = slow-&gt;next;
    if (doomed != NULL) {
        slow-&gt;next = doomed-&gt;next;
        free(doomed);
    }
    return dummy.next;
}</code></pre>
                </div>

                <!-- C++ -->
                <div class="code-panel hidden" data-lang-panel="cpp">
<pre><code class="language-cpp">// C++
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int v) : val(v), next(nullptr) {}
};

ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode dummy(0);
    dummy.next = head;
    ListNode* fast = &amp;dummy;
    ListNode* slow = &amp;dummy;

    for (int i = 0; i &lt;= n; i++) {
        if (!fast) return head; // n too large
        fast = fast-&gt;next;
    }

    while (fast) {
        fast = fast-&gt;next;
        slow = slow-&gt;next;
    }

    ListNode* doomed = slow-&gt;next;
    slow-&gt;next = doomed-&gt;next;
    delete doomed;

    return dummy.next;
}</code></pre>
                </div>

                <!-- Java -->
                <div class="code-panel hidden" data-lang-panel="java">
<pre><code class="language-java">// Java
class ListNode {
    int val;
    ListNode next;
    ListNode(int v) { val = v; }
}

ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode fast = dummy;
    ListNode slow = dummy;

    for (int i = 0; i &lt;= n; i++) {
        if (fast == null) return head; // n too large
        fast = fast.next;
    }

    while (fast != null) {
        fast = fast.next;
        slow = slow.next;
    }

    ListNode doomed = slow.next;
    slow.next = doomed.next;
    // doomed node is eventually GCed

    return dummy.next;
}</code></pre>
                </div>

                <!-- JavaScript -->
                <div class="code-panel hidden" data-lang-panel="js">
<pre><code class="language-javascript">// JavaScript
class ListNode {
    constructor(val, next = null) {
        this.val = val;
        this.next = next;
    }
}

function removeNthFromEnd(head, n) {
    const dummy = new ListNode(0, head);
    let fast = dummy;
    let slow = dummy;

    for (let i = 0; i &lt;= n; i++) {
        if (fast === null) return head; // n too large
        fast = fast.next;
    }

    while (fast !== null) {
        fast = fast.next;
        slow = slow.next;
    }

    const doomed = slow.next;
    if (doomed !== null) {
        slow.next = doomed.next;
    }
    return dummy.next;
}</code></pre>
                </div>

                <!-- C# -->
                <div class="code-panel hidden" data-lang-panel="cs">
<pre><code class="language-csharp">// C#
class ListNode {
    public int Val;
    public ListNode? Next;
    public ListNode(int val) { Val = val; }
}

ListNode? RemoveNthFromEnd(ListNode? head, int n) {
    var dummy = new ListNode(0) { Next = head };
    var fast = dummy;
    var slow = dummy;

    for (int i = 0; i &lt;= n; i++) {
        if (fast == null) return head; // n too large
        fast = fast.Next!;
    }

    while (fast != null) {
        fast = fast.Next!;
        slow = slow.Next!;
    }

    var doomed = slow.Next;
    if (doomed != null) {
        slow.Next = doomed.Next;
    }
    return dummy.Next;
}</code></pre>
                </div>

                <!-- Python -->
                <div class="code-panel hidden" data-lang-panel="py">
<pre><code class="language-python"># Python
from typing import Optional

class ListNode:
    def __init__(self, val: int = 0,
                 next: "Optional[ListNode]" = None) -&gt; None:
        self.val = val
        self.next = next

def remove_nth_from_end(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:
    dummy = ListNode(0, head)
    fast: Optional[ListNode] = dummy
    slow: Optional[ListNode] = dummy

    for _ in range(n + 1):
        if fast is None:
            return head
        fast = fast.next

    while fast is not None:
        fast = fast.next
        slow = slow.next  # type: ignore[assignment]

    doomed = slow.next  # type: ignore[assignment]
    if doomed is not None:
        slow.next = doomed.next  # type: ignore[assignment]
    return dummy.next</code></pre>
                </div>

                <div class="complexity-note">
                    We traverse the list with a single pass (fast and slow) →
                    time <strong>O(n)</strong>. We only use a few pointers and a dummy node →
                    extra space <strong>O(1)</strong>.
                </div>
            </div>
        </section>

        <div class="next-section">
            <a href="problems-section3-linked-lists.html">
                ← Back to Section 3 Problem Set
            </a>
            &nbsp;&nbsp;
            <a href="section10-practice.html">
                Back to Practice Hub →
            </a>
        </div>

        <!-- ======================= Understand-the-algorithm templates ======================= -->

        <div class="deep-dive-template" id="understand-s3p1"
            data-title="Step-by-step: Basic singly linked list operations" hidden>
            <p>
                These three operations all rely on the same core idea: once you have a pointer to the right place in
                the list, you only need to change a couple of <code>next</code> pointers, regardless of the list
                length.
            </p>
            <h3>1. Insert at head</h3>
            <ol>
                <li>
                    <strong>Allocate a new node:</strong>
                    <p>
                        Create a new node and store the value <code>x</code> in its <code>val</code> field.
                    </p>
                </li>
                <li>
                    <strong>Point new node at the old head:</strong>
                    <p>
                        Set <code>node-&gt;next = *head</code> (or <code>node.next = head</code> in higher-level
                        languages). This chains the new node in front of the old list.
                    </p>
                </li>
                <li>
                    <strong>Update head pointer:</strong>
                    <p>
                        Change <code>*head</code> (or return value) so that it now points to the new node. The new node
                        becomes the first element.
                    </p>
                </li>
            </ol>
            <h3>2. Insert after a given node p</h3>
            <ol>
                <li>
                    <strong>Check that p is not null:</strong>
                    <p>
                        If <code>p</code> is <code>NULL</code> / <code>null</code>, there is no valid &quot;after&quot;
                        position, so we simply do nothing.
                    </p>
                </li>
                <li>
                    <strong>Create the new node:</strong>
                    <p>
                        Allocate and fill a node with value <code>x</code>.
                    </p>
                </li>
                <li>
                    <strong>Link new node into the chain:</strong>
                    <ul>
                        <li>First, have it point to what used to come after <code>p</code>:
                            <code>node-&gt;next = p-&gt;next</code>.
                        </li>
                        <li>Then redirect <code>p</code> to point to this new node:
                            <code>p-&gt;next = node</code>.
                        </li>
                    </ul>
                    <p>
                        The list around <code>p</code> goes from <code>p → oldNext</code> to
                        <code>p → node → oldNext</code>.
                    </p>
                </li>
            </ol>
            <h3>3. Delete the node after p</h3>
            <ol>
                <li>
                    <strong>Check that there is something to delete:</strong>
                    <p>
                        If <code>p</code> is <code>NULL</code> or <code>p-&gt;next</code> is <code>NULL</code>, there is
                        no node after <code>p</code>, so we return early.
                    </p>
                </li>
                <li>
                    <strong>Bypass the node to delete:</strong>
                    <p>
                        Let <code>doomed = p-&gt;next</code>. Then set
                        <code>p-&gt;next = doomed-&gt;next</code>. The list now jumps directly from
                        <code>p</code> to the node after <code>doomed</code>.
                    </p>
                </li>
                <li>
                    <strong>Free or drop the node:</strong>
                    <p>
                        In manual-memory languages (like C/C++), call <code>free(doomed)</code> or <code>delete</code>.
                        In GC languages, simply losing all references to <code>doomed</code> is enough.
                    </p>
                </li>
                <li>
                    <strong>Why it&apos;s O(1):</strong>
                    <p>
                        None of these operations walk the list from the head. They only modify local pointers, so they
                        all run in constant time, independent of the list size.
                    </p>
                </li>
            </ol>
        </div>

        <div class="deep-dive-template" id="understand-s3p2"
            data-title="Step-by-step: Reverse a singly linked list in-place" hidden>
            <p>
                The goal is to take a list like <code>1 → 2 → 3 → 4 → null</code> and turn it into
                <code>4 → 3 → 2 → 1 → null</code> by only changing <code>next</code> pointers, using constant extra
                space.
            </p>
            <ol>
                <li>
                    <strong>Track three pointers:</strong>
                    <ul>
                        <li><code>prev</code>: the head of the already-reversed part (initially <code>null</code>).</li>
                        <li><code>curr</code>: the node we are currently processing (starts at <code>head</code>).</li>
                        <li><code>nxt</code>: a temporary pointer to remember <code>curr-&gt;next</code>.</li>
                    </ul>
                </li>
                <li>
                    <strong>Loop while curr is not null:</strong>
                    <p>
                        At each step, we &quot;move&quot; <code>curr</code> from the original list into the front of
                        the reversed list.
                    </p>
                </li>
                <li>
                    <strong>Step-by-step inside the loop:</strong>
                    <ol>
                        <li>
                            <strong>Save the next node:</strong>
                            <p>
                                <code>nxt = curr-&gt;next</code> keeps track of where to continue in the original list.
                            </p>
                        </li>
                        <li>
                            <strong>Reverse the link:</strong>
                            <p>
                                Set <code>curr-&gt;next = prev</code>. Now <code>curr</code> points backward toward the
                                partially reversed list.
                            </p>
                        </li>
                        <li>
                            <strong>Advance prev:</strong>
                            <p>
                                Move <code>prev</code> forward: <code>prev = curr</code>. The reversed list has grown
                                by one node.
                            </p>
                        </li>
                        <li>
                            <strong>Advance curr:</strong>
                            <p>
                                Continue the scan with <code>curr = nxt</code>, the next node from the original list.
                            </p>
                        </li>
                    </ol>
                </li>
                <li>
                    <strong>End of the loop:</strong>
                    <p>
                        When <code>curr</code> becomes <code>null</code>, we have visited every node. The pointer
                        <code>prev</code> now points to the new head of the fully reversed list.
                    </p>
                </li>
                <li>
                    <strong>Why pointers don&apos;t get lost:</strong>
                    <p>
                        We always save <code>curr-&gt;next</code> in <code>nxt</code> before overwriting it. That means
                        we never lose access to the remainder of the list while reversing links.
                    </p>
                </li>
                <li>
                    <strong>Time and space:</strong>
                    <p>
                        Every node&apos;s <code>next</code> pointer is changed exactly once, so the time is
                        O(n). We only use a few extra pointers, so the space is O(1).
                    </p>
                </li>
            </ol>
        </div>

        <div class="deep-dive-template" id="understand-s3p3"
            data-title="Step-by-step: Detect a cycle with Floyd’s tortoise and hare" hidden>
            <p>
                Floyd&apos;s cycle detection algorithm uses two pointers moving at different speeds to determine
                whether a linked list loops back on itself.
            </p>
            <ol>
                <li>
                    <strong>Initialize pointers:</strong>
                    <p>
                        Set both <code>slow</code> and <code>fast</code> to <code>head</code>. If the list is empty,
                        there is no cycle.
                    </p>
                </li>
                <li>
                    <strong>Movement rule:</strong>
                    <ul>
                        <li><code>slow</code> moves one step: <code>slow = slow-&gt;next</code>.</li>
                        <li>
                            <code>fast</code> moves two steps:
                            <code>fast = fast-&gt;next-&gt;next</code> (or the equivalent in your language).
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Check for &quot;no cycle&quot;:</strong>
                    <p>
                        On each iteration, if <code>fast</code> hits <code>null</code> or
                        <code>fast-&gt;next</code> is <code>null</code>, we know there is a tail node and therefore
                        no cycle. We can safely return <code>false</code>.
                    </p>
                </li>
                <li>
                    <strong>Check for a meeting point:</strong>
                    <p>
                        If the list has a cycle, then the faster pointer will eventually &quot;lap&quot; the slower
                        one and they will point to the same node at some iteration. When
                        <code>slow == fast</code>, we return <code>true</code>.
                    </p>
                </li>
                <li>
                    <strong>Why do they meet if there is a cycle?</strong>
                    <p>
                        Think of nodes inside the cycle as positions on a circle. Both pointers enter the circle and
                        then continue moving around it. In each step, <code>fast</code> moves one node more than
                        <code>slow</code>. That means the distance between them (modulo the cycle length) shrinks by 1
                        each iteration. Eventually that distance becomes 0, so they land on the same node.
                    </p>
                </li>
                <li>
                    <strong>Complexity:</strong>
                    <p>
                        Neither pointer visits more than a constant multiple of the list length before we either hit
                        the tail or detect the cycle, so the runtime is O(n). Only a couple of pointers are used, so
                        the space is O(1).
                    </p>
                </li>
            </ol>
        </div>

        <div class="deep-dive-template" id="understand-s3p4"
            data-title="Step-by-step: Find the middle node with slow/fast pointers" hidden>
            <p>
                This pattern is very similar to cycle detection but used to locate the middle of the list instead.
            </p>
            <ol>
                <li>
                    <strong>Initialize pointers:</strong>
                    <p>
                        Set <code>slow = head</code> and <code>fast = head</code>. If the list is empty, the middle is
                        just <code>null</code>.
                    </p>
                </li>
                <li>
                    <strong>Advance at different speeds:</strong>
                    <ul>
                        <li><code>slow</code> moves one node per step: <code>slow = slow-&gt;next</code>.</li>
                        <li><code>fast</code> moves two nodes per step: <code>fast = fast-&gt;next-&gt;next</code>.</li>
                    </ul>
                </li>
                <li>
                    <strong>Stopping condition:</strong>
                    <p>
                        Continue while <code>fast</code> and <code>fast-&gt;next</code> are not <code>null</code>.
                        When that condition fails, <code>fast</code> has reached (or passed) the end of the list.
                    </p>
                </li>
                <li>
                    <strong>Where is slow when we stop?</strong>
                    <p>
                        Since <code>fast</code> moves twice as quickly, by the time <code>fast</code> traverses the
                        entire list, <code>slow</code> has traversed about half of it. That&apos;s exactly the middle
                        node for odd lengths.
                    </p>
                </li>
                <li>
                    <strong>Even-length lists convention:</strong>
                    <p>
                        For an even number of nodes, there are two &quot;middle&quot; positions. With this loop
                        condition, <code>slow</code> ends up pointing to the <em>second</em> middle, which matches the
                        common LeetCode-style convention.
                    </p>
                </li>
                <li>
                    <strong>Complexity:</strong>
                    <p>
                        Both pointers move forward only, so this is still a single pass over the list with O(n) time
                        and O(1) extra space.
                    </p>
                </li>
            </ol>
        </div>

        <div class="deep-dive-template" id="understand-s3p5"
            data-title="Step-by-step: Merge two sorted linked lists" hidden>
            <p>
                The idea is similar to merging two sorted arrays, but we relink existing nodes instead of allocating
                new ones.
            </p>
            <ol>
                <li>
                    <strong>Use a dummy head:</strong>
                    <p>
                        Create a <code>dummy</code> node whose <code>next</code> will become the head of the merged
                        list. Maintain a <code>tail</code> pointer that always points to the last node of the merged
                        list so far.
                    </p>
                </li>
                <li>
                    <strong>Set up two cursors:</strong>
                    <p>
                        Let <code>a = l1</code> and <code>b = l2</code>. These walk down each input list. Initially,
                        <code>tail</code> points to <code>dummy</code>.
                    </p>
                </li>
                <li>
                    <strong>Walk both lists while neither is empty:</strong>
                    <ul>
                        <li>
                            At each step, compare <code>a-&gt;val</code> and <code>b-&gt;val</code>.
                        </li>
                        <li>
                            Attach the smaller node to <code>tail-&gt;next</code> and advance that list&apos;s cursor
                            (<code>a</code> or <code>b</code>).
                        </li>
                        <li>
                            Move <code>tail</code> forward to the node you just attached.
                        </li>
                    </ul>
                    <p>
                        This preserves sorted order because you always choose the smallest remaining head element.
                    </p>
                </li>
                <li>
                    <strong>Attach the remainder:</strong>
                    <p>
                        When one list runs out (<code>a == null</code> or <code>b == null</code>), the other list
                        still has nodes left, and they are already sorted. You can simply set
                        <code>tail-&gt;next</code> to the non-null list (<code>a</code> or <code>b</code>).
                    </p>
                </li>
                <li>
                    <strong>Return the merged head:</strong>
                    <p>
                        The real head of the merged list is <code>dummy.next</code>, since <code>dummy</code> itself
                        was only a convenience node.
                    </p>
                </li>
                <li>
                    <strong>Why this reuses nodes:</strong>
                    <p>
                        We never allocate new list nodes in the merge; we only change <code>next</code> pointers. This
                        makes the algorithm memory-efficient and keeps the original nodes intact.
                    </p>
                </li>
                <li>
                    <strong>Runtime:</strong>
                    <p>
                        Each node from both input lists is processed exactly once, so the time is
                        O(n + m), and the extra space (beyond a couple of pointers) is O(1).
                    </p>
                </li>
            </ol>
        </div>

        <div class="deep-dive-template" id="understand-s3p6"
            data-title="Step-by-step: Remove the N-th node from the end in one pass" hidden>
            <p>
                The trick is to avoid computing the list length explicitly by using two pointers with a fixed gap of
                <code>n</code> nodes between them.
            </p>
            <ol>
                <li>
                    <strong>Use a dummy head:</strong>
                    <p>
                        Create a <code>dummy</code> node that points to the original <code>head</code>. This makes it
                        easy to remove the first real node if needed (for example, when removing the N-th from end and
                        N is the list length).
                    </p>
                </li>
                <li>
                    <strong>Initialize two pointers:</strong>
                    <p>
                        Set <code>fast = dummy</code> and <code>slow = dummy</code>. Both start before the real list.
                    </p>
                </li>
                <li>
                    <strong>Advance fast by n + 1 steps:</strong>
                    <ul>
                        <li>
                            Move <code>fast</code> forward <code>n + 1</code> times. If it becomes <code>null</code>
                            before you finish, then <code>n</code> was larger than the list length, and you can
                            handle that as an error or return the original head.
                        </li>
                        <li>
                            After this, there is a gap of exactly <code>n</code> nodes between <code>slow</code> and
                            <code>fast</code>.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Move both pointers together:</strong>
                    <p>
                        While <code>fast</code> is not <code>null</code>, advance both
                        <code>fast = fast-&gt;next</code> and <code>slow = slow-&gt;next</code>. Because of the gap,
                        when <code>fast</code> hits the end, <code>slow</code> will be just <em>before</em> the node we
                        want to remove.
                    </p>
                </li>
                <li>
                    <strong>Remove slow-&gt;next:</strong>
                    <p>
                        Let <code>doomed = slow-&gt;next</code>. Then set <code>slow-&gt;next = doomed-&gt;next</code>.
                        This bypasses the target node, effectively deleting it from the list. In manual-memory
                        languages, free or delete <code>doomed</code>.
                    </p>
                </li>
                <li>
                    <strong>Return new head:</strong>
                    <p>
                        The new list head is <code>dummy.next</code>. This works even if the original head node was
                        removed.
                    </p>
                </li>
                <li>
                    <strong>Why it&apos;s one pass:</strong>
                    <p>
                        Each pointer only walks the list once. We never restart from the beginning, so the algorithm
                        runs in O(n) time with O(1) extra space.
                    </p>
                </li>
            </ol>
        </div>

        <!-- ======================= Modal shell reused by all buttons ======================= -->

        <div class="deep-dive-backdrop" id="deep-dive-backdrop" aria-hidden="true">
            <div class="deep-dive-modal" role="dialog" aria-modal="true" aria-labelledby="deep-dive-title">
                <button type="button" class="deep-dive-close" aria-label="Close">&times;</button>
                <h2 id="deep-dive-title">&nbsp;</h2>
                <div class="deep-dive-body"></div>
            </div>
        </div>

    </main>
</body>

</html>
